<chapter id="language.references">
 <title>References explained</title>
 <sect1 id="language.references.whatare">
  <title>What are references?</title>
  <simpara>  
  References in PHP are means to call same variable content with different
  names. They are not like C pointers, they are symbol table aliases.
  Note that in PHP, variable names and variable content are different, so
  same content can have different names. The most close analogy is Unix
  filenames and files - variable names are directory entries, while variable
  contents is the file itself. References can be thought of as hardlinking
  in Unix filesystem.
  </simpara>
 </sect1>

 <sect1 id="language.references.whatdo">
  <title>What references do?</title>
  <para>
  PHP references allow you to make two variables to refer to the same
  content. Meaning, when you do:

  <informalexample>
   <programlisting role="php">
    $a = &amp; $b
   </programlisting>
  </informalexample>

  it means that <varname>$a</varname> and <varname>$b</varname> point to 
  the same variable. 
   <note>
   <para>
   <varname>$a</varname> and <varname>$b</varname> are completely equal here,
   that's not <varname>$a</varname> is pointing to <varname>$b</varname> 
   or vice versa, that's <varname>$a</varname> and <varname>$b</varname> 
   pointing to the same place.
   </para>
   </note>
  </para>

  <para>
  The second thing references do is to pass variables by-references. This is
  done by making local function variable and caller variable to be reference
  to the same content. Example:

  <informalexample>
   <programlisting role="php">
     function foo(&amp;$var) {
        $var++;
     }

     $a=5;
     foo($a);
   </programlisting>
  </informalexample>

  will make <varname>$a</varname> to be 6.
  </para>
 </sect1>

 <sect1 id="language.references.arent">
  <title>What references aren't?</title>
  <para>
  As said above. references aren't pointers. That means, the following
  construct won't do what you expect:

  <informalexample>
   <programlisting role="php">
    function foo(&amp;$var) {
      $var =&amp; $GLOBALS["baz"];
    }
     foo($bar);
   </programlisting>
  </informalexample>
  </para>

  <simpara>
  What will happen that <varname>$var</varname> in foo will be bound with 
  <varname>$bar</varname> in caller, but   then it will be re-bound with
  <varname>$GLOBALS["baz"]</varname>. There's no way to bind <varname>$bar</varname>
  in caller to something else using reference mechanism, since 
  <varname>$bar</varname> is not available in the function foo (it is 
  represented by <varname>$var</varname>, but <varname>$var</varname> 
  has only variable contents and not name-to-value binding). 
  </simpara>
 </sect1>

 <sect1 id="language.references.return">
  <title>Returning references</title>
  <para>
  Returning by-refernce it is useful when you want to use function to
  find variable which should be bound to. When returning references, use
  this syntax:

  <informalexample>
   <programlisting role="php">
    function &amp;find_var($param) {
      ...code...
      return $found_var;
    }

    $foo =&amp; find_var($bar);
   </programlisting>
  </informalexample>
  </para>
  <note>
    <simpara>
    Unlike parameter passing, here you use &amp; in both places.
    </simpara>
  </note>
 </sect1>

 <sect1 id="language.references.unset">
  <title>Unsetting references</title>
  <para>
  When you unset the reference, you just break the binding between variable
  name and variable content. This does not mean that variable content will
  be destroyed. For example:

  <informalexample>
   <programlisting role="php">
    $a = 1;
    $b =&amp; $a;
    unset($a);
   </programlisting>
  </informalexample>


  won't unset <varname>$b</varname>, just <varname>$a</varname>. 
  </para>

  <simpara>
  Again, it might be useful to think about this as analogous to Unix unlink
  call.
  </simpara>
 </sect1>

 <sect1 id="language.references.spot">
  <title>Spotting the reference</title>

  <simpara>
  Many syntax constructs in PHP are implemented via referencing mechanisms,
  so everything told above about reference binding also apply to these
  constructs. Some constructs, like passing and returning by-reference, are 
  mentioned above. Other constructs that use references are: 
  </simpara>

  <sect2 id="references.global">
  <title><literal>global</literal></title>

  <para>
   When you declare variable as <command>global $var</command> you are in 
   fact creating reference to a global variable. That means, this is the 
   same as:

  <informalexample>
   <programlisting role="php">
     $var =&amp; $GLOBALS["var"];
   </programlisting>
  </informalexample>
  </para>

  <simpara>
  That means, for example, that unsetting <varname>$var</varname> won't unset
  global variable.
  </simpara>
  </sect2>

  <sect2 id="references.this">
  <title><literal>$this</literal></title>

  <simpara>
   In an object method, $this is always reference to the caller object. 
  </simpara>
  </sect2>
 </sect1>
</chapter>


