<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<sect1 xml:id="language.types.declarations">
 <title>Type declarations</title>

 <para>
  Type declarations can be added to function arguments, return values,
  and, as of PHP 7.4.0, class properties. They ensure that the value
  is of the specified type at call time, otherwise a
  <classname>TypeError</classname> is thrown.
 </para>

 <para>
  PHP's type system supports various base types that can be composed together
  to create more complex types.
 </para>

 <note>
  <para>
   When a class implements an interface method or reimplements a method which
   has already been defined by a parent class, it has to be compatible with the
   aforementioned definition.
   A method is compatible if it follows the
   <link linkend="language.oop5.variance">variance</link> rules.
  </para>
 </note>

 <sect2 xml:id="language.types.declarations.base">
  <title>Base types</title>
  <para>
   Some base types are built-in types which are tightly integrated with the
   language and cannot be reproduced with user defined types.
  </para>

  <para>
   The list of base types is:
   <itemizedlist>
    <listitem>
     <simpara>Primitive types</simpara>
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.declarations.base.scalar">Scalar types</link>:
        <type>bool</type>, <type>int</type>, <type>float</type>, and <type>string</type>
       </simpara>
      </listitem>
      <listitem>
       <simpara><type>array</type> type</simpara>
      </listitem>
      <listitem>
       <simpara><type>object</type> type</simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.declarations.base.class-specific">Class specific types</link>:
        <type>self</type>, <type>parent</type>, and <type>static</type>
       </simpara>
      </listitem>
      <listitem>
       <simpara>Top type <type>mixed</type></simpara>
      </listitem>
      <listitem>
       <simpara>Unit type <type>null</type></simpara>
      </listitem>
      <listitem>
       <simpara>Bottom type <type>never</type></simpara>
      </listitem>
      <listitem>
       <simpara><type>void</type> type</simpara>
      </listitem>
     </itemizedlist>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.declarations.base.literal">Literal types</link>
     </simpara>
     <itemizedlist>
      <listitem>
       <simpara><type>false</type></simpara>
      </listitem>
      <listitem>
       <simpara><type>true</type></simpara>
      </listitem>
     </itemizedlist>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.declarations.base.user-defined">User-defined types</link>
     </simpara>
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.oop5.interfaces">Interfaces</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.oop5.basic.class">Classes</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.enumerations">Enumerations</link></simpara>
      </listitem>
     </itemizedlist>
    </listitem>
    <listitem>
     <simpara><link linkend="language.types.declarations.base.function">Callable type</link></simpara>
    </listitem>
   </itemizedlist>
  </para>

  <sect3 xml:id="language.types.declarations.base.scalar">
   <title>Scalar types</title>
   <para>
    The value of a scalar type declaration must be a value of the specified
    type.
    An exception exists that the type <type>float</type> will always accept
    values of type <type>int</type>.
    Moreover, in coercive typing mode (the default), some other scalar values
    may be coerced into the declared type if the conversion is possible.
    For more information see the
    <link linkend="language.types.declarations.strict">strict type</link> section.
   </para>

   <warning>
    <para>
     Name aliases for scalar types are not supported.
     Instead, they are treated as class or interface names.
     For example, using <literal>boolean</literal> as a type declaration
     will require the value to be an &instanceof; the class or interface
     <literal>boolean</literal>, rather than of type <type>bool</type>:
    </para>
    <para>
     <example>
      <programlisting role="php">
<![CDATA[
<?php
    function test(boolean $param) {}
    test(true);
?>
]]>
      </programlisting>
      &example.outputs.8;
      <screen>
<![CDATA[
Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write "\boolean" to suppress this warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
  thrown in - on line 2
]]>
      </screen>
     </example>
    </para>
   </warning>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.array">
   <title><type>array</type> type</title>
   <para>
    The value must be an <type>array</type>.
    It is not possible to restrict the type of the keys or values within the array.
   </para>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.object">
   <title><type>object</type> type</title>
   <para>
    The value must be an &instanceof; any class or enumeration.
   </para>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.class-specific">
   <title>Class specific types</title>
   <para>
    These types declarations can only be used within classes.
   </para>

   <sect4 xml:id="language.types.declarations.base.class-specific.self">
    <title><type>self</type></title>
    <para>
     The value must be an &instanceof; the same class as the one
     in which the type declaration is used.
    </para>
   </sect4>

   <sect4 xml:id="language.types.declarations.base.class-specific.parent">
    <title><type>parent</type></title>
    <para>
     The value must be an &instanceof; the parent of the class
     in which the type declaration is used.
    </para>
   </sect4>

   <sect4 xml:id="language.types.declarations.base.class-specific.static">
    <title>static</title>
    <para>
     <type>static</type> is a return-only type which requires that the
     value returned must be an &instanceof; the same class as the one
     the method is called in.
     Available as of PHP 8.0.0.
    </para>
   </sect4>
  </sect3>

  <sect3 xml:id="language.types.declarations.mixed">
   <title>Top type - mixed</title>
   <para>
    <type>mixed</type> accepts all value. It is equivalent to the
    <link linkend="language.types.declarations.composite.union">union type</link>
    <type class="union">
     <type>object</type><type>resource</type><type>array</type><type>string</type>
     <type>int</type><type>float</type><type>bool</type><type>null</type>
    </type>.
    Available as of PHP 8.0.0.
   </para>
  </sect3>
  <sect3 xml:id="language.types.declarations.base.null">
   <title>Unit type - null</title>
   <para>
    The <type>null</type> type accepts only the value &null;.
    Available as of PHP 8.0.0.
   </para>
   <warning>
    <simpara>
     Prior to PHP 8.2.0 the <type>null</type> could only be used as part of a
     <link linkend="language.types.declarations.composite.union">union type</link>.
    </simpara>
   </warning>
  </sect3>

  <sect3 xml:id="language.types.declarations.never">
   <title>Bottom type - never</title>
   <para>
    <literal>never</literal> is a return-only type indicating the function
    does not terminate. This means that it either calls <function>exit</function>,
    throws an exception, or is an infinite loop.
    Therefore, it cannot be part of a
    <link linkend="language.types.declarations.composite.union">union type</link>
    declaration. Available as of PHP 8.1.0.
   </para>
   <para>
    <type>never</type> is, in type theory parlance, the bottom type.
    Meaning it is the subtype of every other type and can replace any other
    return type during inheritance.
   </para>
  </sect3>

  <sect3 xml:id="language.types.declarations.void">
   <title>void</title>
   <para>
    <literal>void</literal> is a return-only type declaration indicating the
    function does not return a value, but the function may still terminate.
    Therefore, it cannot be part of a
    <link linkend="language.types.declarations.composite.union">union type</link>
    declaration. Available as of PHP 7.1.0.
   </para>
   <note>
    <simpara>
     Even if a function has a return type of <literal>void</literal> it will
     still return a value, this value is always &null;.
    </simpara>
   </note>
   <note>
    <para>
     Returning by reference from a <type>void</type> function is deprecated as of PHP 8.1.0,
     because such a function is contradictory.
     Previously, it already emitted the following
     <constant>E_NOTICE</constant> when called:
     <literal>Only variable references should be returned by reference</literal>.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function &test(): void {}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.literal">
   <title>Literal types</title>
   <para>
    Literal types are type which not only check the type of a value but also
    the value itself. PHP has support for two literal types:
    <literal>false</literal> as of PHP 8.0.0, and <literal>true</literal>
    as of PHP 8.2.0.
   </para>

   <warning>
    <simpara>
     Prior to PHP 8.2.0 the <literal>false</literal> type could only be used as part of a
     <link linkend="language.types.declarations.composite.union">union type</link>.
    </simpara>
   </warning>

   <note>
    <simpara>
     It is not possible to define custom literal types. Consider using an
     <link linkend="language.types.enumerations">enumerations</link> instead.
    </simpara>
   </note>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.user-defined">
   <title>User-defined types</title>
   <para>
    A user-defined type is any
    <link linkend="language.oop5.interfaces">interface</link>,
    <link linkend="language.oop5.basic.class">class</link>,
    or <link linkend="language.types.enumerations">enumerations</link>.
    The type corresponds to the name of the interface/class/enumeration
    being constrained.

    For classes and interfaces, the value must be an &instanceof; the
    given class or interface.

    For enumerations, the value must be a case of the enumeration.
   </para>

   <note>
    <simpara>
     These types are generally referred to as class-types.
    </simpara>
   </note>
  </sect3>

  <sect3 xml:id="language.types.declarations.base.function">
   <title>Callable types</title>
   <para>
    The value must be a valid <type>callable</type>.
    This type cannot be used as a class property type declaration.
   </para>

   <note>
    <simpara>
     It is not possible to specify the signature of the function.
    </simpara>
   </note>
  </sect3>

  <sect3 xml:id="language.types.declarations.examples">
   &reftitle.examples;
   <example>
    <title>Basic class type declaration</title>
    <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// This doesn't extend C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
    </programlisting>
    &example.outputs.8;
    <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
    </screen>
   </example>

   <example>
    <title>Basic interface type declaration</title>
    <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// This doesn't implement I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
    </programlisting>
    &example.outputs.8;
    <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
    </screen>
   </example>

   <example>
    <title>Basic return type declaration</title>
    <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Note that a float will be returned.
var_dump(sum(1, 2));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
float(3)
]]>
    </screen>
   </example>

   <example>
    <title>Returning an object</title>
    <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
    </screen>
   </example>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.declarations.composite">
  <title>Composite types</title>
  <para>
   It is possible to combine simple types into composite types.
   PHP allows types to be combined in the following ways:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     Union of simple types. As of PHP 8.0.0.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Intersection of class-types (interfaces and class names). As of PHP 8.1.0.
    </simpara>
   </listitem>
   <!--
   <listitem>
    <simpara>
     <acronym>DNF</acronym> types, a union of simple types and
     intersection of class-types. As of PHP 8.2.0.
    </simpara>
   </listitem>
   -->
  </itemizedlist>

  <caution>
   <simpara>
    Prior to PHP 8.2, it was not possible to combine intersection types with union types.
   </simpara>
  </caution>

  <sect3 xml:id="language.types.declarations.composite.union">
   <title>Union types</title>
   <para>
    A union type declaration accepts values of multiple different simple types,
    rather than a single one.
    Union types are specified using the syntax
    <type class="union">
     <type>T1</type><type>T2</type><type>...</type>
    </type>.
    Union types are available as of PHP 8.0.0.
   </para>

   <warning>
    <simpara>
     It is not possible to combine the two literal types <literal>false</literal>
     and <literal>true</literal> together in a union type.
     Use <type>bool</type> instead.
    </simpara>
   </warning>

   <caution>
    <simpara>
     Prior to PHP 8.2.0, as <literal>false</literal> and <type>null</type>
     could not be used as standalone types, a union type comprised of only
     these types was not permitted. This comprises the following types:
     <literal>false</literal>, <literal>false|null</literal>,
     and <literal>?false</literal>.
    </simpara>
   </caution>

   <sect4 xml:id="language.types.declarations.nullable">
    <title>Nullable type syntactic sugar</title>

    <para>
     A single base type declaration can be marked nullable by prefixing the
     type with a question mark (<literal>?</literal>).
     Thus <literal>?T</literal> and <literal>T|null</literal> are identical.
    </para>

    <note>
     <simpara>
      This syntax is supported as of PHP 7.1.0, and predates generalised union
      types support.
     </simpara>
    </note>

    <example>
     <title>Nullable argument type declaration</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(?C $c) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
     </screen>
    </example>

    <example>
     <title>Nullable return type declaration</title>
     <programlisting role="php">
<![CDATA[
<?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
]]>
     </programlisting>
    </example>

    <note>
     <para>
      It is also possible to achieve nullable arguments by making
      <literal>null</literal> the default value.
      This is not recommended as this breaks during inheritance.
     </para>
     <example>
      <title>Old way to make arguments nullable</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </note>
   </sect4>
  </sect3>

  <sect3 xml:id="language.types.declarations.composite.intersection">
   <title>Intersection types</title>
   <para>
    An intersection type declaration accepts values which satisfies multiple
    class-type declarations, rather than a single one.
    Intersection types are specified using the syntax <literal>T1&amp;T2&amp;...</literal>.
    Intersection types are available as of PHP 8.1.0.
   </para>
  </sect3>

  <sect3 xml:id="language.types.declarations.composite.redundant">
   <title>Duplicate and redundant types</title>
   <para>
    To catch simple bugs in composite type declarations, redundant types that
    can be detected without performing class loading will result in a
    compile-time error. This includes:

    <itemizedlist>
     <listitem>
      <simpara>
       Each name-resolved type may only occur once. Types such as
       <literal>int|string|INT</literal> or
       <literal>Countable&amp;Traversable&amp;COUNTABLE</literal>
       result in an error.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Using <type>mixed</type> results in an error.
      </simpara>
     </listitem>
     <listitem>
      <simpara>For union types:</simpara>
      <itemizedlist>
       <listitem>
        <simpara>
         If <type>bool</type> is used, <type>false</type> cannot be used additionally.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         If <type>object</type> is used, class types cannot be used additionally.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         If <type>iterable</type> is used, <type>array</type>
         and <classname>Traversable</classname> cannot be used additionally.
        </simpara>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <simpara>For intersection types:</simpara>
      <itemizedlist>
       <listitem>
        <simpara>
         Using a type which is not a class-type results in an error.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Using either <type>self</type>, <type>parent</type>, or
         <type>static</type> results in an error.
        </simpara>
       </listitem>
      </itemizedlist>
     </listitem>
    </itemizedlist>
   </para>

   <note>
    <simpara>
     This does not guarantee that the type is “minimal”, because doing so would
     require loading all used class types.
    </simpara>
   </note>

   <para>
    For example, if <literal>A</literal> and <literal>B</literal> are class
    aliases, then <literal>A|B</literal> remains a legal union type, even
    though it could be reduced to either <literal>A</literal> or
    <literal>B</literal>.
    Similarly, if class <code>B extends A {}</code>, then <literal>A|B</literal>
    is also a legal union type, even though it could be reduced to just
    <literal>A</literal>.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(): int|INT {} // Disallowed
function foo(): bool|false {} // Disallowed
function foo(): int&Traversable {} // Disallowed
function foo(): self&Traversable {} // Disallowed

use A as B;
function foo(): A|B {} // Disallowed ("use" is part of name resolution)
function foo(): A&B {} // Disallowed ("use" is part of name resolution)

class_alias('X', 'Y');
function foo(): X|Y {} // Allowed (redundancy is only known at runtime)
function foo(): X&Y {} // Allowed (redundancy is only known at runtime)
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.declarations.alias">
  <title>Type aliases</title>

  <para>
   PHP supports a single type alias <type>iterable</type> which corresponds to the
   <link linkend="language.types.declarations.composite.union">union type</link>
   <type class="union">
    <type>array</type><type>Traversable</type>
   </type>.
   This type alias is available as of PHP 7.1.0.
  </para>

  <note>
   <simpara>
    PHP does not support user-defined type aliases.
   </simpara>
  </note>
 </sect2>

 <sect2 xml:id="language.types.declarations.strict">
  <title>Strict typing</title>

  <para>
   By default, PHP will coerce values of the wrong type into the expected
   scalar type declaration if possible. For example, a function that is given
   an <type>int</type> for a parameter that expects a <type>string</type>
   will get a variable of type <type>string</type>.
  </para>

  <para>
   It is possible to enable strict mode on a per-file basis. In strict
   mode, only a value corresponding exactly to the type declaration will be
   accepted, otherwise a <classname>TypeError</classname> will be thrown.
   The only exception to this rule is that an <type>int</type> value will
   pass a <type>float</type> type declaration.
  </para>

  <warning>
   <simpara>
    Function calls from within internal functions will not be affected by
    the <literal>strict_types</literal> declaration.
   </simpara>
  </warning>

  <para>
   To enable strict mode, the &declare; statement is used with the
   <literal>strict_types</literal> declaration:
  </para>

  <note>
   <para>
    Strict typing applies to function calls made from
    <emphasis>within</emphasis> the file with strict typing enabled, not to
    the functions declared within that file. If a file without strict
    typing enabled makes a call to a function that was defined in a file
    with strict typing, the caller's preference (coercive typing) will be
    respected, and the value will be coerced.
   </para>
  </note>

  <note>
   <para>
    Strict typing is only defined for scalar type declarations.
   </para>
  </note>

  <example>
   <title>Strict typing for arguments values</title>
   <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
   </programlisting>
   &example.outputs.8;
   <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
   </screen>
  </example>

  <example>
   <title>Coercive typing for argument values</title>
   <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// These will be coerced to integers: note the output below!
var_dump(sum(1.5, 2.5));
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
int(3)
int(3)
]]>
   </screen>
  </example>

  <example>
   <title>Strict typing for return values</title>
   <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
   </screen>
  </example>
 </sect2>

 <sect2 xml:id="language.types.declarations.union.coercive">
  <title>Coercive typing with union types</title>
  <para>
   When <literal>strict_types</literal> is not enabled, scalar type declarations
   are subject to limited implicit type coercions.
   If the exact type of the value is not part of the union, then the target type
   is chosen in the following order of preference:

   <orderedlist>
    <listitem>
     <simpara>
      <type>int</type>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>float</type>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>bool</type>
     </simpara>
    </listitem>
   </orderedlist>

   If the type both exists in the union, and the value can be coerced to the
   type under PHPs existing type checking semantics, then the type is chosen.
   Otherwise the next type is tried.
  </para>

  <caution>
   <para>
    As an exception, if the value is a string and both int and float are part
    of the union, the preferred type is determined by the existing
    “numeric string” semantics.
    For example, for <literal>"42"</literal> <type>int</type> is chosen,
    while for <literal>"42.0"</literal> <type>float</type> is chosen.
   </para>
  </caution>

  <note>
   <para>
    Types that are not part of the above preference list are not eligible
    targets for implicit coercion. In particular no implicit coercions to
    the <literal>null</literal> and <literal>false</literal> types occur.
   </para>
  </note>

  <example>
   <title>Example of types being coerced into a type part of the union</title>
   <programlisting role="php">
<![CDATA[
<?php
// int|string
42    --> 42          // exact type
"42"  --> "42"        // exact type
new ObjectWithToString --> "Result of __toString()"
                      // object never compatible with int, fall back to string
42.0  --> 42          // float compatible with int
42.1  --> 42          // float compatible with int
1e100 --> "1.0E+100"  // float too large for int type, fall back to string
INF   --> "INF"       // float too large for int type, fall back to string
true  --> 1           // bool compatible with int
[]    --> TypeError   // array not compatible with int or string

// int|float|bool
"45"    --> 45        // int numeric string
"45.0"  --> 45.0      // float numeric string

"45X"   --> true      // not numeric string, fall back to bool
""      --> false     // not numeric string, fall back to bool
"X"     --> true      // not numeric string, fall back to bool
[]      --> TypeError // array not compatible with int, float or bool
?>
]]>
   </programlisting>
  </example>
 </sect2>

<!-- TODO figure out what do to with these things -->
 <sect2 xml:id="language.types.declarations.misc">
  <title>Misc</title>
   <example>
    <title>Typed pass-by-reference Parameters</title>
    <simpara>
     Declared types of reference parameters are checked on function entry, but
     not when the function returns, so after the function had returned, the
     argument's type may have changed.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
]]>
    </programlisting>
    &example.outputs.8;
    <screen>
<![CDATA[
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
  thrown in - on line 2
]]>
    </screen>
   </example>

   <example>
    <title>Catching <classname>TypeError</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: ', $e->getMessage();
}
?>
]]>
    </programlisting>
    &example.outputs.8;
    <screen>
<![CDATA[
int(3)
Error: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 10
]]>
    </screen>
   </example>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
