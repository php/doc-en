<?xml version="1.0" encoding="utf-8"?>
<sect1 xml:id="language.operators.bitwise">
 <title>Bitwise Operators</title>
 <titleabbrev>Bitwise</titleabbrev>
 <simpara>
  Bitwise operators allow evaluation and manipulation of specific
  bits within an integer.
 </simpara>
 <table>
  <title>Bitwise Operators</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Example</entry>
     <entry>Name</entry>
     <entry>Result</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><userinput>$a &amp; $b</userinput></entry>
     <entry>And</entry>
     <entry>Bits that are set in both <varname>$a</varname> and <varname>$b</varname> are set.</entry>
    </row>
    <row>
     <entry><userinput>$a | $b</userinput></entry>
     <entry>Or (inclusive or)</entry>
     <entry>Bits that are set in either <varname>$a</varname> or <varname>$b</varname> are set.</entry>
    </row>
    <row>
     <entry><userinput>$a ^ $b</userinput></entry>
     <entry>Xor (exclusive or)</entry>
     <entry>
      Bits that are set in <varname>$a</varname> or <varname>$b</varname> but not both are set.
     </entry>
    </row>
    <row>
     <entry><userinput>~ $a</userinput></entry>
     <entry>Not</entry>
     <entry>
      Bits that are set in <varname>$a</varname> are not set, and vice versa.
     </entry>
    </row>
    <row>
     <entry><userinput>$a &lt;&lt; $b</userinput></entry>
     <entry>Shift left</entry>
     <entry>
      Shift the bits of <varname>$a</varname> <varname>$b</varname> steps to the left (each step means
      "multiply by two")
     </entry>
    </row>
    <row>
     <entry><userinput>$a &gt;&gt; $b</userinput></entry>
     <entry>Shift right</entry>
     <entry>
      Shift the bits of <varname>$a</varname> <varname>$b</varname> steps to the right (each step means
      "divide by two")
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  Bit shifting in PHP is arithmetic.
  Bits shifted off either end are discarded.
  Left shifts have zeros shifted in on the right while the sign
  bit is shifted out on the left, meaning the sign of an operand
  is not preserved.
  Right shifts have copies of the sign bit shifted in on the left,
  meaning the sign of an operand is preserved.
 </para>
 <para>
  Use parentheses to ensure the desired
  <link linkend="language.operators.precedence">precedence</link>.
  For example, <literal>$a &amp; $b == true</literal> evaluates
  the equivalency then the bitwise and; while
  <literal>($a &amp; $b) == true</literal> evaluates the bitwise and
  then the equivalency.
 </para>
 <para>
  If both operands for the <literal>&amp;</literal>, <literal>|</literal> and
  <literal>^</literal> operators are strings, then the operation will be
  performed on the ASCII values of the characters that make up the strings and
  the result will be a string. In all other cases, both operands will be
  <link linkend="language.types.integer.casting">converted to integers</link>
  and the result will be an integer.
 </para>
 <para>
  If the operand for the <literal>~</literal> operator is a string, the
  operation will be performed on the ASCII values of the characters that make
  up the string and the result will be a string, otherwise the operand and the
  result will be treated as integers.
 </para>
 <para>
  Both operands and the result for the <literal>&lt;&lt;</literal> and
  <literal>&gt;&gt;</literal> operators are always treated as integers.
 </para>
 <para>
  <informalexample>
   <para>
    <literallayout>
     PHP's error_reporting ini setting uses bitwise values,
     providing a real-world demonstration of turning
     bits off. To show all errors, except for notices,
     the php.ini file instructions say to use:
     <userinput>E_ALL &amp; ~E_NOTICE</userinput>
    </literallayout>
   </para>
   <para>
    <literallayout>
     This works by starting with E_ALL:
     <computeroutput>00000000000000000111011111111111</computeroutput>
     Then taking the value of E_NOTICE...
     <computeroutput>00000000000000000000000000001000</computeroutput>
     ... and inverting it via <literal>~</literal>:
     <computeroutput>11111111111111111111111111110111</computeroutput>
     Finally, it uses AND (&amp;) to find the bits turned
     on in both values:
     <computeroutput>00000000000000000111011111110111</computeroutput>
    </literallayout>
   </para>
   <para>
    <literallayout>
     Another way to accomplish that is using XOR (<literal>^</literal>)
     to find bits that are on in only one value or the other:
     <userinput>E_ALL ^ E_NOTICE</userinput>
    </literallayout>
   </para>
  </informalexample>
 </para>
 <para>
  <informalexample>
   <para>
    <literallayout>
     error_reporting can also be used to demonstrate turning bits on.
     The way to show just errors and recoverable errors is:
     <userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
    </literallayout>
   </para>
   <para>
    <literallayout>
     This process combines E_ERROR
     <computeroutput>00000000000000000000000000000001</computeroutput>
     and
     <computeroutput>00000000000000000001000000000000</computeroutput>
     using the OR (<literal>|</literal>) operator
     to get the bits turned on in either value:
     <computeroutput>00000000000000000001000000000001</computeroutput>
    </literallayout>
   </para>
  </informalexample>
 </para>
 <para>
  <example>
   <title>Bitwise AND, OR and XOR operations on integers</title>
   <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignore the top section,
 * it is just formatting to make output clearer.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * Here are the examples.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
   </screen>
  </example>
 </para>
 <para>
  <example>
   <title>Bitwise XOR operations on strings</title>
   <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Outputs '5'

echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Outputs 1
              // 2 ^ ((int) "3") == 1

echo "2" ^ 3; // Outputs 1
              // ((int) "2") ^ 3 == 1
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>Bit shifting on integers</title>
   <programlisting role="php">
<![CDATA[
<?php
/*
 * Here are the examples.
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * Ignore this bottom section,
 * it is just formatting to make output clearer.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
   </programlisting>
   &example.outputs.32bit;
   <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
   </screen>
   &example.outputs.64bit;
   <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
   </screen>
  </example>
 </para>
 <warning>
  <para>
   Use functions from the <link linkend="book.gmp">gmp</link> extension for
   bitwise manipulation on numbers beyond <constant>PHP_INT_MAX</constant>.
  </para>
 </warning>

 <sect2 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
    <member><function>pack</function></member>
    <member><function>unpack</function></member>
    <member><function>gmp_and</function></member>
    <member><function>gmp_or</function></member>
    <member><function>gmp_xor</function></member>
    <member><function>gmp_testbit</function></member>
    <member><function>gmp_clrbit</function></member>
   </simplelist>
  </para>
 </sect2>
</sect1>
