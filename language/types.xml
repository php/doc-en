 <chapter id="language.types">
  <title>Types</title>

  <sect1 id="language.types.intro">
  <title>Introduction</title>
  
  <simpara>
   PHP supports eight primitive <!-- (all types are primitive in php) -->
   types.
  </simpara>
  
  <para>
   Three scalar <!-- (basic, can't be split into parts) --> types:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">boolean</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">integer</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.double">floating-point number (double)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">string</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>

  <para>
   Three compound types:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">array</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">object</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>


  <para>
   And finally two special types:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">resource</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">null</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>


  <simpara>
   The type of a variable is usually not set by the programmer;
   rather, it is decided at runtime by PHP depending on the context in
   which that variable is used.
  </simpara>
  <simpara>
   If you would like to force a variable to be converted to a certain
   type, you may either <link
   linkend="language.types.typecasting">cast</link> the variable or
   use the <function>settype</function> function on it.
  </simpara>
  <simpara>
   Note that a variable may behave in different manners in certain
   situations, depending on what type it is at the time. For more
   information, see the section on <link
   linkend="language.types.type-juggling">Type Juggling</link>.
  </simpara>
  
   
   </sect1>
   
   <sect1 id="language.types.boolean">
    <title>Booleans</title>
    
    <simpara>
     This is the simpelest type. A <type>boolean</type> expresses a 
     truth value. It can be either TRUE or FALSE. 
    </simpara>
    
    <simpara>
     You can use the special case-insensitive constants 'TRUE' and
     'FALSE' to specify a <type>boolean</type> value. Usually you 
     use some kind of <link linkend="language.operators">operator</link>
     which returns a <type>boolean</type> value, and then pass it 
     on to a <link linkend="control-structures">control
     structure</link>.
    </simpara>
    
    <!-- TODO: example of this -->
    
    <!-- TODO: example to show that if ( expr == TRUE ) is not really
         necessary... (i've seen this construct numerous times)
      -->

    <!-- TODO: how others vars are converted to boolean -->

    <note>
     <simpara>
      The boolean-type was introduced in PHP 4
     </simpara>
    </note>
    
    <sect2 id="language.types.boolean.casting">
     <title>Converting to boolean</title>
      <simpara>
       See <link linkend="language.types.type-juggling">type-juggling</link>
       for general information about converting.
      </simpara>
      
      <para>
       When converting to <type>boolean</type>, the following values 
       are considered FALSE:
  
       <itemizedlist>
        <listitem>
         <simpara>the <link linkend="language.types.boolean">boolean</link> 
          FALSE<!-- duh... --></simpara>
        </listitem>
        <listitem>
         <simpara>the <link linkend="language.types.integer">integer</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>the <link linkend="language.types.double">float</link> 
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>the empty <link linkend="language.types.string"
           >string</link>, and the <link linkend="language.types.string"
           >string</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara>an <link linkend="language.types.array">array</link> 
         with zero elements</simpara>
        </listitem>
        <listitem>
         <simpara>an <link linkend="language.types.object">object</link> 
         with zero elements</simpara>
        </listitem>
        <listitem>
         <simpara>the special value <link linkend="language.types.null"
            >NULL</link> 
         </simpara>
        </listitem>
       </itemizedlist>
       
       Every other value is considered TRUE (including any 
       <link linkend="language.types.resource">resource</link>).
       <warning><simpara>-1 is considered TRUE!</simpara></warning>
       <!-- and/or a few examples, for the people only looking at 
            the examples... </XXX> -->
      </para>
      
     
    </sect2>

   </sect1>

   <sect1 id="language.types.integer">
   <title>Integers</title>
   <para>
    Integers can be specified using any of the following syntaxes:
    <informalexample>
     <programlisting role="php">
$a = 1234; # decimal number
$a = -123; # a negative number
$a = 0123; # octal number (equivalent to 83 decimal)
$a = 0x12; # hexadecimal number (equivalent to 18 decimal)
     </programlisting>
    </informalexample>
    The size of an integer is platform-dependent, although a 
    maximum value of about 2 billion is the usual value 
    (that's 32 bits signed).
   </para>
   
    <sect2 id="language.types.integer.overflow">
     <title>Integer overflow</title>
     <para>
      Because of the flexible type-juggling, a number
      is autmatically converted to float when it is about
      to overflow.
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Converting to integer</title>
      <simpara>
       See <link linkend="language.types.type-juggling">type-juggling</link> for 
       general information about converting.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>From <link linkend="language.types.boolean"
           >booleans</link></title>
       <simpara>
        <link linkend="language.types.boolean">False</link> will yield 
        0 (zero), and <link linkend="language.types.boolean">True</link> 
        will yield 1 (one).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>From floating point numbers</title>
       <simpara>
        When converting from float to integer, the number will
        be rounded <emphasis>towards zero</emphasis>.
       </simpara>
       
       <para>
        If the float is beyond the boundaries of integer
        <!-- usually, or is it 'always'? -->
        (usually <literal>+/- 2.15e+9 = 2^31</literal>), 
        the result is undefined, since the float hasn't
        got enough precision to give an exact integer result.
        <warning>
         <simpara>
          No warning, not even a notice will be issued in this 
          case!
         </simpara>
        </warning>
       </para>
       
       <warning><para>
        Never cast an unknown fraction to <type>integer</type>, as this can
        sometimes lead to unexpected results.
        <informalexample><programlisting role="php">
echo (int) ( (0.1+0.7) * 10 ); // echo's 7!
        </programlisting></informalexample>
        
        See for more information the <link 
        linkend="warn.float-precision">warning 
        about float-precision</link>.
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>From strings</title>
       <simpara>
        See <link linkend="language.types.string.conversion">String 
        conversion</link>
       </simpara>
      
    
      </sect3>
    </sect2>
    
    <para>
     See also:
     <link linkend="ref.gmp">Arbitrary precision integeres</link> and
     <link linkend="language.types.double">Floating point numbers</link>
    </para>
      
  </sect1>

  <sect1 id="language.types.double">
   <title>Floating point numbers</title>
   <para>
    Floating point numbers (aka "doubles" or "real numbers") can be 
    specified using any of the following syntaxes: 
    <informalexample>
     <programlisting role="php"> 
$a = 1.234; $a = 1.2e3; $a = 7E-10;
     </programlisting>
    </informalexample>
    <!--  
    
LNUM	[0-9]+
DNUM	([0-9]*[\.][0-9]+)|([0-9]+[\.][0-9]*)
EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})
    
    -->
    The size of a floating point number is platform-dependent, 
    although a maximum of ~1.8e308 with a precision of roughly 14 
    decimal digits is a common value (that's 64 bit IEEE format).
   </para>
   <warning id="warn.float-precision">
    <title>Floating point precision</title>
    <para>
     It is quite usual that simple decimal fractions like
     <literal>0.1</literal> or <literal>0.7</literal> cannot be
     converted into their internal binary counterparts without a
     little loss of precision. This can lead to confusing results: for
     example, <literal>floor((0.1+0.7)*10)</literal> will usually
     return <literal>7</literal> instead of the expected
     <literal>8</literal> as the result of the internal representation
     really being something like <literal>7.9999999999...</literal>.
    </para>
    <para>
     This is related to the fact that it is impossible to exactly
     express some fractions in decimal notation with a finite number
     of digits. For instance, <literal>1/3</literal> in decimal form
     becomes <literal>0.3333333. . .</literal>.
    </para>
    <para>
     So never trust floating number results to the last digit and
     never compare floating point numbers for equality. If you really
     need higher precision, you should use the <link
     linkend="ref.bc">arbitrary precision math functions</link>
     or <link linkend="ref.gmp">gmp</link> functions instead.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.types.string">
   <title>Strings</title>
   <para>
    Strings can be specified using one of two sets of delimiters.
   </para>
   <para>
    If the string is enclosed in double-quotes ("), variables within
    the string will be expanded (subject to some parsing
    limitations). As in C and Perl, the backslash ("\") character can
    be used in specifying special characters:
    <table>
     <title>Escaped characters</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>sequence</entry>
        <entry>meaning</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>linefeed (LF or 0x0A (10) in ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>carriage return (CR or 0x0D (13) in ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>horizontal tab (HT or 0x09 (9) in ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>backslash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>dollar sign</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>double-quote</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         the sequence of characters matching the regular
         expression is a character in octal notation
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         the sequence of characters matching the regular
         expression is a character in hexadecimal notation
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <para>
    If you attempt to escape any other character, both the backslash
    and the character will be output. In PHP 3, a warning will
    be issued at the <literal>E_NOTICE</literal> level when this
    happens. In PHP 4, no warning is generated.
   </para>

   <para>
    The second way to delimit a string uses the single-quote ("'")
    character. When a string is enclosed in single quotes, the only
    escapes that will be understood are "\\" and "\'". This is for
    convenience, so that you can have single-quotes and backslashes in
    a single-quoted string. Variables will <emphasis>not</emphasis> be
    expanded inside a single-quoted string.
   </para>

   <simpara>
    Another way to delimit strings is by using here doc syntax
    ("&lt;&lt;&lt;").  One should provide an identifier after
    <literal>&lt;&lt;&lt;</literal>, then the string, and then the
    same identifier to close the quotation. 
   </simpara>
   
   <simpara>
    The closing identifier <emphasis>must</emphasis> begin in the
    first column of the line.  Also, the identifier used must follow
    the same naming rules as any other label in PHP: it must contain
    only alphanumeric characters and underscores, and must start with
    a non-digit character or underscore.
   </simpara>

   <para>
    Here doc text behaves just like a double-quoted string, without
    the double-quotes. This means that you do not need to escape quotes
    in your here docs, but you can still use the escape codes listed
    above. Variables are expanded, but the same care must be taken
    when expressing complex variables inside a here doc as with
    strings.
    <example> 
     <title>Here doc string quoting example</title>
     <programlisting>
&lt;?php
$str = &lt;&lt;&lt;EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this-&gt;foo = 'Foo';
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &lt;&lt;&lt;EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo-&gt;bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
     Here doc support was added in PHP 4.
    </para>
   </note>
   <para>
    Strings may be concatenated using the '.' (dot) operator. Note
    that the '+' (addition) operator will not work for this. Please
    see <link linkend="language.operators.string">String
    operators</link> for more information.
   </para>
   <para>
    Characters within strings may be accessed by treating the string
    as a numerically-indexed array of characters, using C-like
    syntax. See below for examples.
   </para>
   <para>
    <example>
     <title>Some string examples</title>
     <programlisting role="php">
&lt;?php
/* Assigning a string. */
$str = "This is a string";

/* Appending to it. */
$str = $str . " with some more text";

/* Another way to append, includes an escaped newline. */
$str .= " and a newline at the end.\n";

/* This string will end up being '&lt;p&gt;Number: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;Number: $num&lt;/p&gt;";

/* This one will be '&lt;p&gt;Number: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;Number: $num&lt;/p&gt;';

/* Get the first character of a string  */
$str = 'This is a test.';
$first = $str[0];

/* Get the last character of a string. */
$str = 'This is still a test.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>
    <sect2 id="language.types.string.parsing">
     <title>String parsing</title>
     <!-- 
     I used simpara all over, because I don't know when
     to use para. There will also probably some typo's
     and misspellings.
     -->
     <simpara>
      When a string is specified in double quotes, variables are
      parsed within it. 
     </simpara>
     <simpara>
      There are two types of syntax, a 
      <link linkend="language.types.string.parsing.simple">simple</link>
      one and a 
      <link linkend="language.types.string.parsing.complex">complex</link>
      one.
      The simple syntax is the most common and convenient, it provides a way
      to parse a variable, an array-value, or a object-property.
     </simpara>
     <simpara>
      The complex syntax was introduced in PHP 4,
      <!-- XXX was it? and starting with what version exactly? -->
      and can by recognised
      by the curly braces surrounding the expression.
     </simpara>
     <sect3 id="language.types.string.parsing.simple">
      <title>Simple syntax</title>
      <simpara>
       If a $ is encoutered, the parser will
       greedily take as much tokens as possible to form a valid
       variable name. Enclose the the variable name in curly
       braces if you want to explicitely specify the end of the
       name.
      </simpara>
      <informalexample>
       <programlisting role="php">
 $beer = 'Heineken';
 echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
 echo "He drunk some $beers"; // won't work, 's' is a valid character for varnames
 echo "He drunk some ${beer}s"; // works
       </programlisting>
      </informalexample>
      <simpara>
       Similary, you can also have an array-index and an 
       object-property parsed. With array-indices, the
       ']' marks the end of the index, for object-properties
       the same rules apply as to simple variables, though
       with object properties there doesn't exist a trick
       like the one with variables.
       
       <!-- XXX isn't true :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
 $fruits = array( 'strawberry' =&gt; 'red' , 'banana' =&gt; 'yellow' );
 echo "A banana is $fruits[banana].";
 echo "This square is $square-&gt;width meters broad.";
 echo "This square is $square-&gt;width00 centimeters broad."; // won't work,
    // for a solution, see the <link linkend="language.types.string.parsing.complex">complex syntax</link>.
 
 <!-- XXX this won't work:
 echo "This square is $square->{width}00 centimeters broad."; 
 // XXX: php developers: it would be consequent to make this work.
 // XXX: like the $obj->{expr} syntax outside a string works, 
 // XXX: analogously to the ${expr} syntax for variable var's.
 -->
 
       </programlisting>
      </informalexample>
      <simpara>
       For anything more complex, you should use the complex syntax.
      </simpara>
     </sect3>
     <sect3 id="language.types.string.parsing.complex">
      <title>Complex (curly) syntax</title>
      <simpara>
       I didn't call this complex because the syntax is complex,
       but because you can include complex expressions this way.
     </simpara>
     <simpara>
      In fact, you can include any value that is in the namespace
      in strings with this syntax. You simply write the expression
      the same way as you would outside the string, and then include
      it in { and }. Since you can't escape '{', this syntax will
      only be recognised when the $ is immediately following the {.
      (Use "{\$" or "\{$" to get a literal "{$").
      Some examples to make it clear:
     </simpara>
     <informalexample>
      <programlisting role="php">
 $great = 'fantastic';
 echo "This is { $great}"; // won't work, outputs: This is { fantastic}
 echo "This is {$great}";  // works, outputs: This is fantastic
 echo "This square is {$square-&gt;width}00 centimeters broad."; 
 echo "This works: {$arr[4][3]}";     
 echo "This is wrong: {$arr[foo][3]}"; // for the same reason 
    // as $foo[bar] is wrong outside a string. 
 <!-- XXX see the still-to-write explaination in the arrays-section. -->
 echo "You should do it this way: {$arr['foo'][3]}";
 echo "You can even write {$obj-&gt;values[3]-&gt;name}";
 echo "This is the value of the var named $name: {${$name}}";
 
 <!-- <xxx> maybe it's better to leave this out?? -->
 // this works, but i disencourage its use, since this is NOT 
 // involving functions, rather than mere variables, arrays and objects.
 $beer = 'Heineken';
 echo "I'd like to have another {${ strrev('reeb') }}, hips";
 <!-- </xxx> -->
 
       </programlisting>
      </informalexample>
     </sect3>
    </sect2>
   <sect2 id="language.types.string.conversion">
    <title>String conversion</title>

    <simpara>
     When a string is evaluated as a numeric value, the resulting
     value and type are determined as follows.
    </simpara>
    <simpara>
     The string will evaluate as a double if it contains any of the
     characters '.', 'e', or 'E'. Otherwise, it will evaluate as an
     integer.
    </simpara>
    <para>
     The value is given by the initial portion of the string. If the
     string starts with valid numeric data, this will be the value
     used. Otherwise, the value will be 0 (zero). Valid numeric data
     is an optional sign, followed by one or more digits (optionally
     containing a decimal point), followed by an optional
     exponent. The exponent is an 'e' or 'E' followed by one or more
     digits.
    </para>
    <simpara>
     When the first expression is a string, the type of the variable
     will depend on the second expression.
    </simpara>
    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo is float (11.5)
$foo = 1 + "-1.3e3";            // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";         // $foo is integer (1)
$foo = 1 + "bob3";              // $foo is integer (1)
$foo = 1 + "10 Small Pigs";     // $foo is integer (11)
$foo = 1 + "10 Little Piggies"; // $foo is integer (11)
$foo = "10.0 pigs " + 1;        // $foo is integer (11)
$foo = "10.0 pigs " + 1.0;      // $foo is float (11)     
     </programlisting>
    </informalexample>
    <simpara>
     For more information on this conversion, see the Unix manual page
     for strtod(3).
    </simpara>
    <para>
     If you would like to test any of the examples in this section,
     you can cut and paste the examples and insert the following line
     to see for yourself what's going on:
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; type is " . gettype ($foo) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Arrays actually act like both hash tables (associative arrays) and
    indexed arrays (vectors).
   </para>

   <sect2 id="language.types.array.single-dim">
    <title>Single Dimension Arrays</title>

    <para>
     PHP supports both scalar and associative arrays. In fact, there
     is no difference between the two.  You can create an array using
     the <function>list</function> or <function>array</function>
     functions, or you can explicitly set each array element value.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can also create an array by simply adding values to the
     array. When you assign a value to an array variable using empty
     brackets, the value will be added onto the end of the array.
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays may be sorted using the <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, and
     <function>uksort</function> functions depending on the type of
     sort you want.
    </para>
    <para>
     You can count the number of items in an array using the
     <function>count</function> function.
    </para>
    <para>
     You can traverse an array using <function>next</function> and
     <function>prev</function> functions.  Another common way to
     traverse an array is to use the <function>each</function>
     function.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Multi-Dimensional Arrays</title>

    <para>
     Multi-dimensional arrays are actually pretty simple.  For each
     dimension of the array, you add another [key] value to the end:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;   

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 3 it is not possible to reference multidimensional arrays
     directly within strings. For instance, the following will not
     have the desired result:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "This won't work: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP 3, the above will output <computeroutput>This won't work:
     Array[bar]</computeroutput>. The string concatenation operator,
     however, can be used to overcome this:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: " . $a[3]['bar'];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 4, however, the whole problem may be circumvented by
     enclosing the array reference (inside the string) in curly
     braces:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can "fill up" multi-dimensional arrays in many ways, but the
     trickiest one to understand is how to use the
     <function>array</function> command for associative arrays.  These
     two snippets of code fill up the one-dimensional array in the
     same way:
     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     The <function>array</function> function can be nested for
     multi-dimensional arrays:
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objects</title>

   <sect2 id="language.types.object.init">
    <title>Object Initialization</title>

    <para>
     To initialize an object, you use the <literal>new</literal>
     statement to instantiate the object to a variable.

     <informalexample>
      <programlisting role="php">
&lt;?php
class foo {
    function do_foo() { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     For a full discussion, please read the section <link
     linkend="language.oop">Classes and Objects</link>.
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>
    
    <para>
     A resource is a special variable, holding
     a reference to an external resource. Resources
     are created and used by special functions.
     See the <link linkend="resource">appendix</link> 
     for a listing of all these
     functions and the corresponding resource-types.
     
    </para>
    
    <note>
     <simpara>
      The resource-type was introduced in PHP 4
     </simpara>
    </note>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freeing resources</title>
    
    <para>
     Due to the reference-counting system introduced
     with PHP4's Zend-engine, it is automatically detected
     when a resource is no longer referred to (just
     like Java). When this is
     the case, all resources that were in use for this 
     resource are made free by the garbage collector.
     For this reason, it is rarely ever necessary to
     free the memory manually by using some free_result
     function.
     <note>
      <simpara>
       Persistant database-links are special, they 
       are <emphasis>not</emphasis> destroyed by the 
       gc. See also <link 
       linkend="features.persistent-connections">persistent 
       links</link>
      </simpara>
     </note>
    </para>
    
   </sect2>
  
   
   
  </sect1>
    
  <sect1 id="language.types.null">
   <title>Null</title>
    
    <note>
     <simpara>
      The null-type was introduced in PHP 4
     </simpara>
    </note>
  
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type Juggling</title>

   <simpara>
    PHP does not require (or support) explicit type definition in
    variable declaration; a variable's type is determined by the
    context in which that variable is used. That is to say, if you
    assign a string value to variable <parameter>var</parameter>,
    <parameter>var</parameter> becomes a string. If you then assign an
    integer value to <parameter>var</parameter>, it becomes an
    integer.
   </simpara>
   <para>
    An example of PHP's automatic type conversion is the addition
    operator '+'. If any of the operands is a double, then all
    operands are evaluated as doubles, and the result will be a
    double. Otherwise, the operands will be interpreted as integers,
    and the result will also be an integer. Note that this does NOT
    change the types of the operands themselves; the only change is in
    how the operands are evaluated.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo is string (ASCII 48)
$foo++;      // $foo is the string "1" (ASCII 49)
$foo += 1;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a double (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If the last two examples above seem odd, see <link
    linkend="language.types.string.conversion">String
    conversion</link>.
   </simpara>
   <simpara>
    If you wish to force a variable to be evaluated as a certain type,
    see the section on <link linkend="language.types.typecasting">Type
    casting</link>. If you wish to change the type of a variable, see
    <function>settype</function>.
   </simpara>
   <para>
    If you would like to test any of the examples in this section, you
    can cut and paste the examples and insert the following line to
    see for yourself what's going on:
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; type is " . gettype ($foo) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     The behaviour of an automatic conversion to array is currently
     undefined.
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a is an integer
$a[0] = "f";  // $a becomes an array, with $a[0] holding "f"
      </programlisting>
     </informalexample>
    </para>
    <para>
     While the above example may seem like it should clearly result in
     $a becoming an array, the first element of which is 'f', consider
     this:
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Since PHP supports indexing into strings via offsets using the
     same syntax as array indexing, the example above leads to a
     problem: should $a become an array with its first element being
     "f", or should "f" become the first character of the string $a?
    </para>
    <para>
     For this reason, as of PHP 3.0.12 and PHP 4.0b3-RC4, the result
     of this automatic conversion is considered to be undefined. Fixes
     are, however, being discussed.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Type Casting</title>

    <para>
     Type casting in PHP works much as it does in C: the name of the
     desired type is written in parentheses before the variable which
     is to be cast.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo is an integer
$bar = (double) $foo;   // $bar is a double
      </programlisting>
     </informalexample>
    </para>
    <para>
     The casts allowed are:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - cast to integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - cast to boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - cast to double</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - cast to string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - cast to array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - cast to object</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note that tabs and spaces are allowed inside the parentheses, so
     the following are functionally equivalent:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     It may not be obvious exactly what will happen when casting
     between certain types. For more info, see these sections:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Converting to 
        boolean</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Converting to 
        integer</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.double.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        null</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    
    </para>
    <para>
     <!-- TODO: move to 'converting to string' -->
     When casting or forcing a conversion from array to string, the
     result will be the word <literal>Array</literal>. When casting or
     forcing a conversion from object to string, the result will be
     the word <literal>Object</literal>. 
     
     <!-- not with my PHP, not even a notice... maybe in PHP3? 
     Does someone know? 
     
     In both cases a warning will
     be issued. -->
    </para>
    <para>
     When casting from a scalar or a string variable to an array, the
     variable will become the first element of the array:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // outputs 'ciao'  
      </programlisting>
     </informalexample>
    </para>
    <para>
     When casting from a scalar or a string variable to an object, the
     variable will become an attribute of the object; the attribute
     name will be 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1 
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
