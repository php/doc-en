<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="language.error-handling" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Error Handling</title>
 <para>
  Errors are a normal part of the development and life cycle of an application.
  As such PHP provides multiple ways to inform and deal with errors.
 </para>
 <para>
  PHP has two main mechanisms for reporting errors:
  <itemizedlist>
   <listitem>
    <para>
     <classname>Throwable</classname> errors, which are further split into
     <emphasis>programming</emphasis> errors via the <classname>Error</classname>
     class hierarchy and <emphasis>recoverable</emphasis> errors via the
     <classname>Exception</classname> class hierarchy.
    </para>
   </listitem>
   <listitem>
    <para>
     Diagnostic errors which are classified into different
     <link linkend="errorfunc.constants">severities</link>.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <sect1 xml:id="language.error-handling.throwable">
  <title><classname>Throwable</classname> errors</title>
  <para>
   Most errors in PHP are of this type.
   A <classname>Throwable</classname> error, is an execution event which disrupts
   the normal flow of instructions. When a <classname>Throwable</classname> error
   is &throw;n, be that by the engine or manually, it will unwind the call stack
   all the way up to the global scope and terminate the program with a fatal error.
   All &finally; blocks it encounters along the way will be executed.
  </para>
  <para>
   To throw a <classname>Throwable</classname> error from within PHP code, one
   must use the &throw; keyword followed by an instance of the
   <classname>Error</classname> or <classname>Exception</classname> class or
   a subclass of one of them.
   Trying to throw an object that is not will result in an
   <classname>Error</classname> being thrown with the following message:
   <literal>Cannot throw objects that do not implement Throwable</literal>.
  </para>
  <tip>
   <para>
    The <link linkend="intro.spl">Standard PHP Library (SPL)</link> provides
    various <link linkend="spl.exceptions">built-in exceptions</link>.
    And it's possible to create custom exceptions by
    <link linkend="language.error-handling.throwable.extending">extending
     <classname>Exception</classname></link>.
   </para>
  </tip>
  <para>
   It is possible to handle a <classname>Throwable</classname> error within PHP
   by surrounding the code susceptible to throw an error in a &try; block.
   A &try; block must have at least one corresponding &catch; or &finally; block.
  </para>
  <note>
   <para>
    It is <emphasis>not</emphasis> recommended to catch <classname>Error</classname>
    objects as those signal a programming error.
   </para>
  </note>
  <warning>
   <para>
    <classname>Throwable</classname> objects cannot be cloned.
    Attempting to <link linkend="language.oop5.cloning">clone</link> such an
    object will result in an <classname>Error</classname> being thrown with
    the following message:
    <literal>Trying to clone an uncloneable object of class Exception</literal>.
   </para>
  </warning>
  
  <sect2 xml:id="language.error-handling.throwable.user">
   <title><literal>Global exception handler</literal></title>
   <para>
    If a <classname>Throwable</classname> object is allowed to bubble up to the
    global scope, it may be caught by a global exception handler if set.
    The <function>set_exception_handler</function> function can set a function
    that will be called in place of a &catch; block if no other block is invoked.
    The effect is essentially the same as if the entire program were wrapped
    in a &try;-&catch; block with that function as the &catch;.
   </para>
  </sect2>

  <sect2 xml:id="language.error-handling.throwable.extending">
   <title>Extending Exceptions</title>
   <para>
    A User defined exception can be defined by extending the built-in
    <classname>Exception</classname> class.
    To see which methods and properties are accessible within a child class
    derived from <classname>Exception</classname> visit its page.
   </para>
   <para>
    If a class extends the built-in <classname>Exception</classname> class and
    re-defines the <link linkend="language.oop5.decon">constructor</link>,
    it is highly recommended that it also call <code>parent::__construct()</code>
    to ensure all available data has been properly assigned.
    The <link linkend="object.tostring">__toString()</link> method can be overridden
    to provide a custom output when the object is used as a string.
   </para>
   <example>
    <title>Extending <classname>Exception</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class CustomException extends Exception
{
    // Redefine the constructor so message isn't optional
    public function __construct($message, $code = 0, Exception $previous = null) {
        // some code

        // Ensure everything is assigned properly
        parent::__construct($message, $code, $previous);
    }

    // Custom string representation of object
    public function __toString() {
        return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
    }

    public function customFunction() {
        echo "A custom function for this type of exception\n";
    }
}

try {
    throw new CustomException("Something happened", 5);
} catch (CustomException $e) {
    echo "Caught custom exception\n", $e;
    $e->customFunction();
}
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Caught custom exception
CustomException: [5]: Something happened
A custom function for this type of exception
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.error-handling.throwable.hierarchy">
   <title><classname>Throwable</classname> hierarchy</title>

   <itemizedlist>
    <listitem>
     <simpara><classname>Throwable</classname></simpara>
     <itemizedlist>
      <listitem>
       <simpara><classname>Error</classname></simpara>
       <itemizedlist>
        <listitem>
         <simpara><classname>ArithmeticError</classname></simpara>
         <itemizedlist>
          <listitem>
           <simpara><classname>DivisionByZeroError</classname></simpara>
          </listitem>
         </itemizedlist>
        </listitem>
        <listitem>
         <simpara><classname>AssertionError</classname></simpara>
        </listitem>
        <listitem>
         <simpara><classname>CompileError</classname></simpara>
         <itemizedlist>
          <listitem>
           <simpara><classname>ParseError</classname></simpara>
          </listitem>
         </itemizedlist>
        </listitem>
        <listitem>
         <simpara><classname>TypeError</classname></simpara>
         <itemizedlist>
          <listitem>
           <simpara><classname>ArgumentCountError</classname></simpara>
          </listitem>
         </itemizedlist>
        </listitem>
        <listitem>
         <simpara><classname>ValueError</classname></simpara>
        </listitem>
        <listitem>
         <simpara><classname>UnhandledMatchError</classname></simpara>
        </listitem>
       </itemizedlist>
      </listitem>
      <listitem>
       <simpara><classname>Exception</classname></simpara>
       <itemizedlist>
        <listitem>
         <simpara>...</simpara>
        </listitem>
       </itemizedlist>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>

 <sect1 xml:id="language.error-handling.diagnostic">
  <title>Diagnostic errors</title>
  <para>
   Diagnostic errors, also known as traditional errors, are used to signal a
   number of different conditions, and can be displayed and/or logged as required.
   By default PHP will report all diagnostic errors. (Prior to PHP 8.0,
   <constant>E_NOTICE</constant> and <constant>E_DEPRECATED</constant>
   diagnostics were not reported by default.)
  </para>
  <para>
   In contrast to <classname>Throwable</classname> errors, diagnostic errors do
   <emphasis>not</emphasis> disrupt the normal flow of execution.
  </para>
  <para>
   Which diagnostics are reported and which are ignored is controlled by the
   <link linkend="ini.error-reporting"><parameter>error_reporting</parameter></link>
   &php.ini; directive, or at runtime by calling <function>error_reporting</function>.
   It is strongly recommended that the configuration directive be set,
   as some errors can occur before execution of your script begins.
  </para>
  <note>
   <para>
    In a development environment,
    <link linkend="ini.error-reporting"><parameter>error_reporting</parameter></link>
    should always be set to <constant>E_ALL</constant> to be aware of and fix
    issues raised by PHP.
    However, in production the level of verbosity could be reduced to
    <code>E_ALL &amp; ~E_NOTICE &amp; ~E_DEPRECATED</code>, but in many cases
    <constant>E_ALL</constant> is still appropriate, as it may provide early
    warning of potential issues.
   </para>
  </note>

  <para>
   What happens to the diagnostics depends on two further &php.ini; directives.
   <link linkend="ini.display-errors"><parameter>display_errors</parameter></link>
   controls whether the diagnostic is shown as part of the script's output.
   This should always be disabled in a production environment, as it can include
   confidential information such as database passwords, but is often useful to
   enable in development, as it ensures immediate reporting of issues.
  </para>

  <para>
   In addition to displaying errors, PHP can log diagnostics when the
   <link linkend="ini.log-errors"><parameter>log_errors</parameter></link>
   directive is enabled. This will log any diagnostic to the file or syslog
   defined by
   <link linkend="ini.error-log"><parameter>error_log</parameter></link>.
   This can be extremely useful in a production environment, as diagnostics are
   logged when they occur and can then generate reports based on those logs.
  </para>
  <para>
   Individual diagnostics can be suppressed using the
   <literal linkend="language.operators.errorcontrol">@</literal> operator.
  </para>

  <warning>
   <para>
    Prior to PHP 8.0.0 it was possible to suppress critical diagnostics that
    would terminate the execution of the PHP script.
   </para>
  </warning>

  <note>
   <para>
    Diagnostics can be added, removed, have their severity altered or be
    elevated to a <classname>Throwable</classname> error in between PHP versions.
   </para>
  </note>

  <sect2 xml:id="language.error-handling.diagnostic.user">
   <title>User defined diagnostic handler</title>

   <para>
    If PHP's default diagnostic handling is inadequate,
    it is possible to override the default diagnostic handler with a custom one
    which is set by using <function>set_error_handler</function>.
    Only non-fatal diagnostic can be handled this way, but they can then be
    handled in various ways. For example, this can be used to show a custom
    error page to the user and then report more directly than via a log, such
    as by sending an e-mail.
   </para>

   <para>
    Another typical usage is to elevate diagnostic errors to exceptions with
    <link linkend="class.errorexception">ErrorException</link>.
   </para>
   <example>
    <title>Elevating diagnostic errors to exceptions</title>
    <programlisting role="php">
<![CDATA[
<?php
function exceptions_error_handler($severity, $message, $filename, $lineno) {
    if (error_reporting() & $severity)) {
       throw new ErrorException($message, 0, $severity, $filename, $lineno);
    }
}

set_error_handler('exceptions_error_handler');
?>
]]>
    </programlisting>
    <note>
     <para>
      It is important to verify that the severity is included in the current
      list of reportable diagnostics, otherwise the
      <literal linkend="language.operators.errorcontrol">@</literal> operator
      will be broken, as an exception will be thrown for a suppressed diagnostic.
      <!-- TODO: add an example? -->
     </para>
    </note>
   </example>
  </sect2>
 </sect1>
</chapter>
