<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<refentry xml:id="function.call-user-func-array" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>call_user_func_array</refname>
  <refpurpose>Call a callback with an array of parameters</refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>call_user_func_array</methodname>
   <methodparam><type>callable</type><parameter>callback</parameter></methodparam>
   <methodparam><type>array</type><parameter>param_arr</parameter></methodparam>
  </methodsynopsis>
  <para>
   Calls the <parameter>callback</parameter> given by the first parameter with
   the parameters in <parameter>param_arr</parameter>.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>callback</parameter></term>
     <listitem>
      <para>
       The <type>callable</type> to be called.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>param_arr</parameter></term>
     <listitem>
      <para>
       The parameters to be passed to the callback, as an indexed array.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Returns the return value of the callback, or &false; on error.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title><function>call_user_func_array</function> example</title>
    <programlisting role="php">
<![CDATA[
<?php
function foobar($arg, $arg2) {
    echo __FUNCTION__, " got $arg and $arg2\n";
}
class foo {
    function bar($arg, $arg2) {
        echo __METHOD__, " got $arg and $arg2\n";
    }
}


// Call the foobar() function with 2 arguments
call_user_func_array("foobar", array("one", "two"));

// Call the $foo->bar() method with 2 arguments
$foo = new foo;
call_user_func_array(array($foo, "bar"), array("three", "four"));
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
foobar got one and two
foo::bar got three and four
]]>
    </screen>
   </example>
   <example>
    <title><function>call_user_func_array</function> using namespace name</title>
    <programlisting role="php">
<![CDATA[
<?php

namespace Foobar;

class Foo {
    static public function test($name) {
        print "Hello {$name}!\n";
    }
}

// As of PHP 5.3.0
call_user_func_array(__NAMESPACE__ .'\Foo::test', array('Hannes'));

// As of PHP 5.3.0
call_user_func_array(array(__NAMESPACE__ .'\Foo', 'test'), array('Philip'));

?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Hello Hannes!
Hello Philip!
]]>
    </screen>
   </example>
   <example>
    <title>Using lambda function</title>
    <programlisting role="php">
<![CDATA[
<?php

$func = function($arg1, $arg2) {
    return $arg1 * $arg2;
};

var_dump(call_user_func_array($func, array(2, 4))); /* As of PHP 5.3.0 */

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
int(8)
]]>
    </screen>
   </example>
   <example>
    <title>Passing values by reference</title>
    <programlisting role="php">
<![CDATA[
<?php

function mega(&$a){
    $a = 55;
    echo "function mega \$a=$a\n";
}
$bar = 77;
call_user_func_array('mega',array(&$bar));
echo "global \$bar=$bar\n";

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
function mega $a=55
global $bar=55
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    Before PHP 5.4, referenced variables in <parameter>param_arr</parameter>
    are passed to the function by reference, regardless of whether the function
    expects the respective parameter to be passed by reference. This form of
    call-time pass by reference does not emit a deprecation notice, but it is
    nonetheless deprecated, and has been removed in PHP 5.4.
    Furthermore, this does not apply to internal functions, for which
    the function signature is honored. Passing by value when the function
    expects a parameter by reference results in a warning and having
    <function>call_user_func</function> return &false; (there is, however, an
    exception for passed values with reference count = 1, such as in literals,
    as these can be turned into references without ill effects — but also
    without writes to that value having any effect —; do not rely
    in this behavior, though, as the reference count is an implementation
    detail and the soundness of this behavior is questionable).
   </para>
  </note>
  &note.func-callback-exceptions;
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>call_user_func</function></member>
    <member>&seealso.callback;</member>
    <member><methodname>ReflectionFunction::invokeArgs</methodname></member>
    <member><methodname>ReflectionMethod::invokeArgs</methodname></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
