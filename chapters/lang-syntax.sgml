 <chapter id="lang-syntax">
  <title>Syntax and grammar</title>
 
   <simpara>
    PHP's syntax is borrowed primarily from C.  Java and Perl have
    also influenced the syntax.

  <sect1 id="basic-syntax">
   <title>Basic Syntax</title>

   <sect2 id="basic-syntax.phpmode">
    <title>Escaping from HTML</title>
  
    <para>
     There are four ways of escaping from HTML and entering "PHP code
     mode":

    <para>
     <example>
      <title>Ways of escaping from HTML</title>
      <programlisting>
1.  &lt;? echo ("this is the simplest, an SGML processing instruction\n"); ?>
 
2.  &lt;?php echo("if you want to serve XML documents, do like this\n"); ?>

3.  &lt;script language="php"> 
        echo ("some editors (like FrontPage) don't
              like processing instructions");
    &lt;/script>

4.  &lt;% echo ("As of PHP 3.0.4 you may optionally use ASP-style tags"); %>
    &lt;%= $variable; # This is a shortcut for "&lt;%echo .." %>
      </programlisting>
     </example>

    <para>
     The first way is only available if short tags have been enabled
     (either by calling <function>short_tags</function>, they are
     configured on using the short_tags run-time configuration setting,
     or they are enabled using the --enable-short-tags compile-time
     configuration setting.

    <para>
     The fourth way is only available if ASP-style tags have been
     enabled using either the asp_tags configuration setting or the
     --enable-asp-tags compile-time configuration setting.

    <para>
     The closing "bracket" for the block will include the immediately
     trailing newline if one is present.

   <sect2 id="basic-syntax.instruction-separation">
    <title>Instruction separation</title>

    <simpara>
     Instructions are separated the same as in C or perl - terminate
     each statement with a semicolon.

    <para>
     The closing tag (?&gt;) also implies the end of the statement, so the
     following are equivalent:

     <informalexample>
      <programlisting>
&lt;?php
    echo "This is a test";
?>

&lt;?php echo "This is a test" ?>
      </programlisting>
     </informalexample>

   <sect2 id="basic-syntax.comments">
    <title>Comments</title>
   
    <para>
     PHP supports 'C', 'C++' and Unix shell-style comments. For example:

    <informalexample><programlisting>
&lt;?php
    echo "This is a test"; // This is a one-line c++ style comment
    /* This is a multi line comment
       yet another line of comment */
    echo "This is yet another test";
    echo "One Final Test"; # This is shell-style style comment
?>
     </programlisting>
    </informalexample>

    <simpara>
     The "one-line" comment styles actually only comment to the
     end of the line or the current block of PHP code, whichever
     comes first.
    <informalexample><programlisting>
&lt;h1>This is an &lt;?# echo "simple";?> example.&lt;/h1>
&lt;p>The header above will say 'This is an example'.
</programlisting></informalexample> 

    <simpara>
     You should be careful not to nest 'C' style comments, which can
     happen when commenting out large blocks.

    <informalexample><programlisting>
&lt;?php
 /* 
    echo "This is a test"; /* This comment will cause a problem */
 */
?>
    </programlisting></informalexample>

  <sect1 id="types">
   <title>Types</title>

   <para>
    PHP supports the following types:

    <itemizedlist>
     <listitem><simpara><link linkend="types.integer">integer</link>
     <listitem><simpara><link linkend="types.double">floating-point numbers</link>
     <listitem><simpara><link linkend="types.string">string</link>
     <listitem><simpara><link linkend="types.array">array</link>
     <listitem><simpara><link linkend="types.object">object</link>
    </itemizedlist>

   <simpara>
    The type of a variable is usually not set by the programmer;
    rather, it is decided at runtime by PHP depending on the context
    in which that variable is used.

   <simpara>
    If you would like to force a variable to be converted to a certain 
    type, you may either <link
     linkend="lang-syntax.typecasting">cast</link> the variable or use 
    the <function>settype</function> function on it.

   <simpara>
    Note that a variable may behave in different manners in certain
    situations, depending on what type it is a the time. For more
    information, see the section on <link
     linkend="variables.type-juggling">Type Juggling</link>.

   <sect2 id="types.integer">
    <title>Integers</title>
    <para>
     Integers can be specified using any of the following syntaxes:
    <informalexample><programlisting>
$a = 1234; # decimal number
$a = -123; # a negative number
$a = 0123; # octal number (equivalent to 83 decimal)
$a = 0x12; # hexadecimal number (equivalent to 18 decimal)
</programlisting></informalexample>

   <sect2 id="types.double">
    <title>Floating point numbers</title>
    <para>
     Floating point numbers ("doubles") can be specified using any
     of the following syntaxes:
    <informalexample><programlisting>
$a = 1.234;
$a = 1.2e3;
</programlisting></informalexample>

   <sect2 id="types.string">
    <title>Strings</title>
    <para>
     Strings can be specified using one of two sets of delimiters.
    <para>
     If the string is enclosed in double-quotes ("), variables
     within the string will be expanded (subject to some parsing
     limitations). As in C and Perl, the backslash ("\") character
     can be used in specifying special characters:
    <table>
     <title>Escaped characters</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>sequence</entry>
        <entry>meaning</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>newline</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>carriage</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>horizontal tab</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>backslash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>dollar sign</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>double-quote</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <para>
     You can escape any other character, but a warning will be issued
     at the highest warning level.
    <para>
     The second way to delimit a string uses the single-quote ("'")
     character, which does not do any variable expansion or backslash
     processing (except for "\\" and "\'" so you can insert backslashes
     and single-quotes in a singly-quoted string).

   <sect2 id="types.array">
    <title>Arrays</title>

    <para>
     Arrays actually act like both hash tables (associative arrays)
     and indexed arrays (vectors).

    <sect3 id="types.array.single-dim">
     <title>Single Dimension Arrays</title>

     <para>
      PHP supports both scalar and associative arrays. In fact, there
      is no difference between the two.  You can create an array using
      the <function>list</function> or <function>array</function>
      functions, or you can explicitly set each array element value.

     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>

     <para>
      You can also create an array by simply adding values to
      the array.

     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>

     <para>
      Arrays may be sorted using the <function>asort</function>,
      <function>arsort</function>, <function>ksort</function>,
      <function>rsort</function>, <function>sort</function>,
      <function>uasort</function>, <function>usort</function>, and
      <function>uksort</function> functions depending on the type of
      sort you want.

     <para>
      You can count the number of items in an array using the
      <function>count</function> function.

     <para>
      You can traverse an array using <function>next</function> and
      <function>prev</function> functions.  Another common way to
      traverse an array is to use the <function>each</function>
      function.

    <sect3 id="types.array.multi-dim">
     <title>Multi-Dimensional Arrays</title>

     <para>
      Multi-dimensional arrays are actually pretty simple.  For each
      dimension of the array, you add another [key] value to the end:

     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;   

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>

     <para>
      You can "fill up" multi-dimensional arrays in many ways,
      but the trickiest one to understand is how to use the
      <function>array</function> command for associative arrays.
      These two snippets of code fill up the one-dimensional array in
      the same way:

     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;


# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>

     <para>
      The <function>array</function> function can be nested for 
      multi-dimensional arrays:

     <informalexample>
      <programlisting role="php"> 
&lt;?
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>

   <sect2 id="types.object">
    <title>Objects</title>

    <sect3 id="types.object.init">
     <title>Object Initialization</title>

     <para>
      To initialize an object, you use the new statement to instantiate
      the object to a variable.

      <informalexample>
       <programlisting>
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar -> do_foo ();
       </programlisting>
      </informalexample>

  <sect1 id="variables">
   <title>Variables</title>

   <sect2 id="variables.scope">
    <title>Variable scope</title>

    <simpara>
     The scope of a variable is the context within which it is defined.
     For the most part all PHP variables only have a single scope.
     However, within user-defined functions a local function scope is
     introduced.  Any variable used inside a function is by default
     limited to the local function scope.  For example:
    
    <informalexample>
     <programlisting> 
$a = 1; /* global scope */ 

Function Test () { 
    echo $a; /* reference to local scope variable */ 
} 

Test ();
     </programlisting>
    </informalexample>

    <simpara>
     This script will not produce any output because the echo statement
     refers to a local version of the $a variable, and it has not been
     assigned a value within this scope.  You may notice that this is a
     little bit different from the C language in that global variables
     in C are automatically available to functions unless specifically
     overridden by a local definition.  This can cause some problems in
     that people may inadvertently change a global variable.  In PHP
     global variables must be declared global inside a function if they
     are going to be used in that function.  An example:

    <informalexample>
     <programlisting>
$a = 1;
$b = 2;

Function Sum () {
    global $a, $b;

    $b = $a + $b;
} 

Sum ();
echo $b;
     </programlisting>
    </informalexample>

    <simpara>
     The above script will output &quot;3&quot;.  By declaring $a and
     $b global within the function, all references to either variable
     will refer to the global version.  There is no limit to the number
     of global variables that can be manipulated by a function.

    <simpara>
     A second way to access variables from the global scope is to use
     the special PHP-defined $GLOBALS array.  The previous example can
     be rewritten as:

    <informalexample>
     <programlisting>
$a = 1;
$b = 2;

Function Sum () {
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
} 

Sum ();
echo $b;
     </programlisting>
    </informalexample>

    <simpara>
     The $GLOBALS array is an associative array with the name of the
     global variable being the key and the contents of that variable
     being the value of the array element.

    <simpara>
     Another important feature of variable scoping is the
     <emphasis>static</emphasis> variable.  A static variable exists
     only in a local function scope, but it does not lose its value
     when program execution leaves this scope.  Consider the following
     example:

    <informalexample>
     <programlisting>
Function Test () {
    $a = 0;
    echo $a;
    $a++;
}
     </programlisting>
    </informalexample>

    <simpara>
     This function is quite useless since every time it is called it
     sets $a to 0 and prints &quot;0&quot;.  The $a++ which increments
     the variable serves no purpose since as soon as the function exits
     the $a variable disappears.  To make a useful counting function
     which will not lose track of the current count, the $a variable is
     declared static:

    <informalexample>
     <programlisting>
Function Test () {
    static $a = 0;
    echo $a;
    $a++;
}
     </programlisting>
    </informalexample>

    <simpara>
     Now, every time the Test() function is called it will print the
     value of $a and increment it.

    <simpara>
     Static variables are also essential when functions are called
     recursively.  A recursive function is one which calls itself.
     Care must be taken when writing a recursive function because it is
     possible to make it recurse indefinitely.  You must make sure you
     have an adequate way of terminating the recursion.  The following
     simple function recursively counts to 10:

    <informalexample>
     <programlisting>
Function Test () {
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        Test ();
    }
    $count--;
}
     </programlisting>
    </informalexample>

   <sect2 id="variables.variable">
    <title>Variable variables</title>

    <simpara>
     Sometimes it is convenient to be able to have variable variable
     names.  That is, a variable name which can be set and used
     dynamically.  A normal variable is set with a statement such as:

    <informalexample>
     <programlisting>
$a = "hello";
     </programlisting>
    </informalexample>

    <simpara>
     A variable variable takes the value of a variable and treats that as the
     name of a variable.  In the above example, <emphasis>hello</emphasis>, can
     be used as the name of a variable by using two dollar signs. ie.

    <informalexample>
     <programlisting>
$$a = "world";
     </programlisting>
    </informalexample>

    <simpara>
     At this point two variables have been defined and stored in the
     PHP symbol tree: $a with contents "hello" and $hello with contents
     "world".  Therefore, this statement:

    <informalexample>
     <programlisting>
echo "$a ${$a}";
     </programlisting>
    </informalexample>

    <simpara>
     produces the exact same output as:

    <informalexample>
     <programlisting>
echo "$a $hello";
     </programlisting>
    </informalexample>

    <simpara>
     ie. they both produce: <emphasis>hello world</emphasis>.

    <simpara>
     In order to use variable variables with arrays, you have to
     resolve an ambiguity problem.  That is, if you write $$a[1] then
     the parser needs to know if you meant to use $a[1] as a variable,
     or if you wanted $$a as the variable and then the [1] index from
     that variable.  The syntax for resolving this ambiguity is:
     ${$a[1]} for the first case and ${$a}[1] for the second.

   <sect2 id="variables.external">
    <title>Variables from outside PHP</title>

    <sect3 id="variables.external.form">
     <title>HTML Forms (GET and POST)</title>

     <simpara>
      When a form is submitted to a PHP script, any variables from that
      form will be automatically made available to the script by
      PHP. For instance, consider the following form:

     <para>
      <example>
       <title>Simple form variable</title>
       <programlisting>
&lt;form action="foo.php3" method="post">
    Name: &lt;input type="text" name="name">&lt;br>
    &lt;input type="submit">
&lt;/form>
       </programlisting>
      </example>

     <simpara>
      When submitted, PHP will create the variable
      <computeroutput>$name</computeroutput>, which will will contain
      whatever what entered into the <emphasis>Name:</emphasis> field
      on the form.

     <simpara>
      PHP also understands arrays in the context of form variables, but
      only in one dimension. You may, for example, group related
      variables together, or use this feature to retrieve values from a
      multiple select input:

     <para>
     <example>
      <title>More complex form variables</title>
       <programlisting>
&lt;form action="array.html" method="post">
    Name: &lt;input type="text" name="personal[name]">&lt;br>
    Email: &lt;input type="text" name="personal[email]">&lt;br>
    Beer: &lt;br>
    &lt;select multiple name="beer[]">
        &lt;option value="warthog">Warthog
        &lt;option value="guinness">Guinness
        &lt;/select>
    &lt;input type="submit">
&lt;/form>
       </programlisting>
      </example>

      <simpara>
       If PHP's track_vars feature is turned on, either by the <link
       linkend="ini.track-vars">track_vars</link> configuration setting
       or the <computeroutput>&lt;?php_track_vars?&gt;</computeroutput>
       directive, then variables submitted via the POST or GET methods
       will also be found in the global associative arrays
       $HTTP_POST_VARS and $HTTP_GET_VARS as appropriate.

     <sect4>
      <title>IMAGE SUBMIT variable names</TITLE>

      <simpara>
       When submitting a form, it is possible to use an image instead
       of the standard submit button with a tag like:

      <informalexample>
       <programlisting>
&lt;input type=image src="image.gif" name="sub">
       </programlisting>
      </informalexample>

      <simpara>
       When the user clicks somewhere on the image, the accompanying
       form will be transmitted to the server with two additional
       variables, sub_x and sub_y. These contain the coordinates of
       the user click within the image.  The experienced may note that
       the actual variable names sent by the browser contains a period
       rather than an underscore, but PHP converts the period to an
       underscore automatically.

    <sect3 id="variables.external.cookies">
     <title>HTTP Cookies</title>

     <simpara>
      PHP transparently supports HTTP cookies as defined by <ulink
      url="&spec.cookies;">Netscape's Spec</ulink>.  Cookies are a
      mechanism for storing data in the remote browser and thus
      tracking or identifying return users.  You can set cookies using
      the <function>SetCookie</function> function.  Cookies are part
      of the HTTP header, so the SetCookie function must be called
      before any output is sent to the browser.  This is the same
      restriction as for the <function>Header</function> function.
      Any cookies sent to you from the client will automatically be
      turned into a PHP variable just like GET and POST method data.

     <simpara>
      If you wish to assign multiple values to a single cookie, just
      add <emphasis>[]</emphasis> to the cookie name.  For example:

     <informalexample>
      <programlisting>
SetCookie ("MyCookie[]", "Testing", time()+3600);
      </programlisting>
     </informalexample>

     <simpara>
      Note that a cookie will replace a previous cookie by the same
      name in your browser unless the path or domain is different.  So,
      for a shopping cart application you may want to keep a counter
      and pass this along.  i.e.

     <example>
      <title>SetCookie Example</title>
      <programlisting>
$Count++;
SetCookie ("Count", $Count, time()+3600);
SetCookie ("Cart[$Count]", $item, time()+3600);
      </programlisting>
     </example>

    <sect3 id="variables.external.environment">
     <title>Environment variables</title>

     <para>
      PHP automatically makes environment variables available as normal
      PHP variables.
     
     <informalexample>
      <programlisting>
echo $HOME;  /* Shows the HOME environment variable, if set. */
      </programlisting>
     </informalexample>

     <para>
      Since information coming in via GET, POST and Cookie mechanisms
      also automatically create PHP variables, it is sometimes best to
      explicitly read a variable from the environment in order to make
      sure that you are getting the right version.  The
      <function>getenv</function> function can be used for this.  You
      can also set an environment variable with the
      <function>putenv</function> function.

   <sect2 id="variables.type-juggling">
    <title>Type juggling</title>

    <simpara>
     PHP does not require (or support) explicit type definition in
     variable declaration; a variable's type is determined by the
     context in which that variable is used. That is to say, if you
     assign a string value to variable <parameter>var</parameter>,
     <parameter>var</parameter> becomes a string. If you then assign
     an integer value to <parameter>var</parameter>, it becomes an
     integer.

    <para>
     An example of PHP's automatic type conversion is the addition
     operator '+'. If any of the operands is a double, then all
     operands are evaluated as doubles, and the result will be a
     double. Otherwise, the operands will be interpreted as integers,
     and the result will also be an integer. Note that this does NOT
     change the types of the operands themselves; the only change is
     in how the operands are evaluated.

    <informalexample>
     <programlisting>
$foo = "0";  // $foo is string (ASCII 48)
$foo++;      // $foo is the string "1" (ASCII 49)
$foo += 1;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a double (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
     </programlisting>
    </informalexample>

    <simpara>
     If the last two examples above seem odd, see <link
     linkend="lang-syntax.stringconv">String conversion</link>.  

    <simpara>
     If you wish to force a variable to be evaluated as a certain
     type, see the section on <link
     linkend="lang-syntax.typecasting">Type casting</link>. If you
     wish to change the type of a variable, see
     <function>settype</function>.

    <sect3>
     <title>Determining variable types</title>

     <para>
      Because PHP determines the types of variables and converts them
      (generally) as needed, it is not always obvious what type a given
      variable is at any one time.  PHP includes several functions
      which find out what type a variable is. They are
      <function>gettype</function>, <function>is_long</function>,
      <function>is_double</function>, <function>is_string</function>,
      <function>is_array</function>, and
      <function>is_object</function>.
     
    <sect3 id="lang-syntax.typecasting">
     <title>Type casting</title>

     <para>
      Type casting in PHP works much as it does in C: the name of the
      desired type is written in parentheses before the variable which
      is to be cast.

     <informalexample>
      <programlisting>
$foo = 10;   // $foo is an integer
$bar = (double) $foo;   // $bar is a double
      </programlisting>
     </informalexample>
    
     <para>
      The casts allowed are:
      <itemizedlist>
       <listitem><simpara>(int), (integer) - cast to integer
       <listitem><simpara>(real), (double), (float) - cast to double
       <listitem><simpara>(string) - cast to string
       <listitem><simpara>(array) - cast to array
       <listitem><simpara>(object) - cast to object
      </itemizedlist>

     <para>
      Note that tabs and spaces are allowed inside the parentheses, so
      the following are functionally equivalent:

     <informalexample>
      <programlisting>
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>

    <sect3 id="lang-syntax.stringconv">
     <title>String conversion</title>

     <simpara>
      When a string is evaluated as a numeric value, the resulting
      value and type are determined as follows.

     <simpara>
      The string will evaluate as a double if it contains any of the
      characters '.', 'e', or 'E'. Otherwise, it will evaluate as an
      integer.
     
     <para>
      The value is given by the initial portion of the string. If the
      string starts with valid numeric data, this will be the value
      used. Otherwise, the value will be 0 (zero). Valid numeric data
      is an optional sign, followed by one or more digits (optionally
      containing a decimal point), followed by an optional
      exponent. The exponent is an 'e' or 'E' followed by one or more
      digits.

     <informalexample>
      <programlisting>
$foo = 1 + "10.5";      // $foo is double (11.5)
$foo = 1 + "-1.3e3";    // $foo is double (-1299)
$foo = 1 + "bob-1.3e3"; // $foo is integer (1)
$foo = 1 + "bob3";      // $foo is integer (1)
$foo = 1 + "10 Small Pigs";     // $foo is integer (11)
$foo = 1 + "10 Little Piggies"; // $foo is integer (11); 
$foo = "10.0 pigs " + 1;        // $foo is int (11)
$foo = "10.0 pigs " + 1.0;      // $foo is double (11)     
      </programlisting>
     </informalexample>

     <simpara>
      The type of the variable depends on the second not on the first
      expression, when the first expression is a string.

     <simpara>
      For more information on this conversion, see the Unix manual
      page for strtod(3).
  </sect1>

  <sect1 id="constants">
   <title>Constants</title>

   <simpara>
    PHP defines several constants and provides a mechanism for defining
    more at run-time. Constants are much like variables, save for the two
	facts that constants must be defined using the
	<function>define</function> function, and that they cannot later
	be redefined to another value.

   <para>
	The predefined constants (always available) are:

	<variablelist>

	 <varlistentry>
	  <term>__FILE__</term>
	  <listitem>
	   <simpara>
		The name of the script file presently being parsed. If used
		within a file which has been included or required, then the
		name of the included file is given, and not the name of the
		parent file.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>__LINE__</term>
	  <listitem>
	   <simpara>
		The number of the line within the current script file which is
		being parsed. If used within a file which has been included or
		required, then the position within the included file is given.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>PHP_VERSION</term>
	  <listitem>
	   <simpara>
		The string representation of the version of the PHP parser
		presently in use; e.g. '3.0.8-dev'.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>PHP_OS</term>
	  <listitem>
	   <simpara>
		The name of the operating system on which the PHP parser is
		executing; e.g. 'Linux'.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>TRUE</term>
	  <listitem>
	   <simpara>
		A true value.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>FALSE</term>
	  <listitem>
	   <simpara>
		A false value.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>E_ERROR</term>
	  <listitem>
	   <simpara>
		Denotes an error other than a parsing error from which
		recovery is not possible. 
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>E_WARNING</term>
	  <listitem>
	   <simpara>
		Denotes a condition where PHP knows something is wrong, but
		will continue anyway; these can be caught by the script
		itself. An example would be an invalid regexp in
		<function>ereg</function>. 
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>E_PARSE</term>
	  <listitem>
	   <simpara>
		The parser choked on invalid syntax in the script
		file. Recovery is not possible.
	   </simpara>
	  </listitem>
	 </varlistentry>

	 <varlistentry>
	  <term>E_NOTICE</term>
	  <listitem>
	   <simpara>
		Something happened which may or may not be an error. Execution 
		continues. Examples include using an unquoted string as a
		hash index, or accessing a variable which has not been set.
	   </simpara>
	  </listitem>
	 </varlistentry>
	</variablelist>

   <para>
	The E_* constants are typically used with the
	<function>error_reporting</function> function for setting the
	error reporting level.

   <para>
    You can define additional constants using the
    <function>define</function> function.
	
   <para>
	Note that these are constants, not C-style macros; only valid
	scalar data may be represented by a constant.

    <example>
     <title>Defining Constants</title>
     <programlisting>
&lt;?php
define("CONSTANT", "Hello world.");
echo CONSTANT; // outputs "Hello world."
?&gt;
     </programlisting>
    </example>

    <example>
     <title>Using __FILE__ and __LINE__</title>
     <programlisting>
&lt;?php
function report_error($file, $line, $message) {
    echo "An error occured in $file on line $line: $message.";
}

report_error(__FILE__,__LINE__, "Something went wrong!");
?&gt;
     </programlisting>
    </example>
  </sect1>
	
  <sect1 id="expressions">
   <title>Expressions</title>

   <simpara>
    Expressions are the most important building stones of PHP.  In PHP,
    almost anything you write is an expression.  The simplest yet
    most accurate way to define an expressions is "anything that has a
    value".

   <simpara>
    The most basic forms of expressions are constants and variables.
    When you type "$a = 5", you're assigning '5' into $a.  '5', obviously,
    has the value 5, or in other words '5' is an expression with the
    value of 5 (in this case, '5' is an integer constant).

   <simpara>
    After this assignment, you'd expect $a's value to be 5 as
    well, so if you wrote $b = $a, you'd expect it to behave just as
    if you wrote $b = 5.  In other words, $a is an expression with the
    value of 5 as well.  If everything works right, this is exactly
    what will happen.

   <para>
    Slightly more complex examples for expressions are functions.  For
    instance, consider the following function:

    <informalexample>
     <programlisting>
function foo () {
    return 5;
}
     </programlisting>
    </informalexample>

   <simpara>
    Assuming you're familiar with the concept of functions (if you're
    not, take a look at the chapter about functions), you'd assume
    that typing <literal>$c = foo()</literal> is essentially just like
    writing <literal>$c = 5</literal>, and you're right.  Functions
    are expressions with the value of their return value.  Since foo()
    returns 5, the value of the expression 'foo()' is 5.  Usually
    functions don't just return a static value but compute something.

   <simpara>
    Of course, values in PHP don't have to be integers, and very often
    they aren't.  PHP supports three scalar value types: integer values,
    floating point values and string values (scalar values are values that
    you can't 'break' into smaller pieces, unlike arrays, for instance).
    PHP also supports two composite (non-scalar) types: arrays and
    objects.  Each of these value types can be assigned into variables or
    returned from functions.

   <simpara>
    So far, users of PHP/FI 2 shouldn't feel any change.  However, PHP
    takes expressions much further, in the same way many other
    languages do.  PHP is an expression-oriented language, in the
    sense that almost everything is an expression.  Consider the
    example we've already dealt with, '$a = 5'.  It's easy to see that
    there are two values involved here, the value of the integer
    constant '5', and the value of $a which is being updated to 5 as
    well.  But the truth is that there's one additional value involved
    here, and that's the value of the assignment itself.  The
    assignment itself evaluates to the assigned value, in this case 5.
    In practice, it means that '$a = 5', regardless of what it does,
    is an expression with the value 5.  Thus, writing something like
    '$b = ($a = 5)' is like writing '$a = 5; $b = 5;' (a semicolon
    marks the end of a statement).  Since assignments are parsed in a
    right to left order, you can also write '$b = $a = 5'.

   <simpara>
    Another good example of expression orientation is pre- and
    post-increment and decrement.  Users of PHP/FI 2 and many other
    languages may be familiar with the notation of variable++ and
    variable--.  These are increment and decrement operators.  In
    PHP/FI 2, the statement '$a++' has no value (is not an
    expression), and thus you can't assign it or use it in any way.
    PHP enhances the increment/decrement capabilities by making
    these expressions as well, like in C.  In PHP, like in C, there
    are two types of increment - pre-increment and post-increment.
    Both pre-increment and post-increment essentially increment the
    variable, and the effect on the variable is idential.  The
    difference is with the value of the increment expression.
    Pre-increment, which is written '++$variable', evaluates to the
    incremented value (PHP increments the variable before reading its
    value, thus the name 'pre-increment').  Post-increment, which is
    written '$variable++' evaluates to the original value of
    $variable, before it was incremented (PHP increments the variable
    after reading its value, thus the name 'post-increment').

   <simpara>
    A very common type of expressions are comparison expressions.
    These expressions evaluate to either 0 or 1, meaning FALSE or TRUE
    (respectively).  PHP supports > (bigger than), >= (bigger than or
    equal to), == (equal), < (smaller than) and <= (smaller than or
    equal to).  These expressions are most commonly used inside
    conditional execution, such as IF statements.

   <simpara>
    The last example of expressions we'll deal with here is combined
    operator-assignment expressions.  You already know that if you
    want to increment $a by 1, you can simply write '$a++' or '++$a'.
    But what if you want to add more than one to it, for instance 3?
    You could write '$a++' multiple times, but this is obviously not a
    very efficient or comfortable way.  A much more common practice is
    to write '$a = $a + 3'.  '$a + 3' evaluates to the value of $a
    plus 3, and is assigned back into $a, which results in
    incrementing $a by 3.  In PHP, as in several other languages
    like C, you can write this in a shorter way, which with time would
    become clearer and quicker to understand as well.  Adding 3 to the
    current value of $a can be written '$a += 3'.  This means exactly
    "take the value of $a, add 3 to it, and assign it back into $a".
    In addition to being shorter and clearer, this also results in
    faster execution.  The value of '$a += 3', like the value of a
    regular assignment, is the assigned value.  Notice that it is NOT
    3, but the combined value of $a plus 3 (this is the value that's
    assigned into $a).  Any two-place operator can be used in this
    operator-assignment mode, for example '$a -= 5' (subtract 5 from
    the value of $a), '$b *= 7' (multiply the value of $b by 7), etc.

   <para>
    There is one more expression that may seem odd if you haven't seen
    it in other languages, the ternary conditional operator:

    <informalexample><programlisting>
$first ? $second : $third
</programlisting></informalexample>

    If the value of the first subexpression is true (non-zero), then
    it the second subexpression is evaluated, and that is the result
    of the conditional expression. Otherwise, the third subexpression
    is evaluated, and that is the value.

   <para>
    The following example should help you understand pre- and
    post-increment and expressions in general a bit better:

    <informalexample>
     <programlisting>
function double($i) {
    return $i*2;
}
$b = $a = 5;        /* assign the value five into the variable $a and $b */
$c = $a++;          /* post-increment, assign original value of $a 
                       (5) to $c */
$e = $d = ++$b;     /* pre-increment, assign the incremented value of 
                       $b (6) to $d and $e */

/* at this point, both $d and $e are equal to 6 */

$f = double($d++);  /* assign twice the value of $d <emphasis>before</emphasis> 
                       the increment, 2*6 = 12 to $f */
$g = double(++$e);  /* assign twice the value of $e <emphasis>after</emphasis>
                       the increment, 2*7 = 14 to $g */
$h = $g += 10;      /* first, $g is incremented by 10 and ends with the 
                       value of 24. the value of the assignment (24) is 
                       then assigned into $h, and $h ends with the value 
                       of 24 as well. */
</programlisting></informalexample>

   <simpara>
    In the beginning of the chapter we said that we'll be describing
    the various statement types, and as promised, expressions can be
    statements.  However, not every expression is a statement.  In
    this case, a statement has the form of 'expr' ';' that is, an
    expression followed by a semicolon.  In '$b=$a=5;', $a=5 is a
    valid expression, but it's not a statement by itself.  '$b=$a=5;'
    however is a valid statement.

   <simpara>
    One last thing worth mentioning is the truth value of expressions.
    In many events, mainly in conditional execution and loops, you're
    not interested in the specific value of the expression, but only
    care about whether it means TRUE or FALSE (PHP doesn't have a
    dedicated boolean type).  The truth value of expressions in PHP is
    calculated in a similar way to perl.  Any numeric non-zero numeric
    value is TRUE, zero is FALSE.  Be sure to note that negative
    values are non-zero and are thus considered TRUE!  The empty
    string and the string "0" are FALSE; all other strings are TRUE.
    With non-scalar values (arrays and objects) - if the value
    contains no elements it's considered FALSE, otherwise it's
    considered TRUE.

   <simpara>
    PHP provides a full and powerful implementation of expressions, and
    documenting it entirely goes beyond the scope of this manual. The
    above examples should give you a good idea about what expressions
    are and how you can construct useful expressions. Throughout the
    rest of this manual we'll write <replaceable>expr</replaceable>
    to indicate any valid PHP expression.

  <sect1 id="operators">
   <title>Operators</title>
   <simpara>
   </simpara>

   <sect2 id="arithmetic-operators">
    <title>Arithmetic Operators</title>
    <simpara>
     Remember basic arithmetic from school? These work just
     like those.
    </simpara>

    <table>
     <title>Arithmetic Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>example</entry>
        <entry>name</entry>
        <entry>result</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Addition</entry>
        <entry>Sum of $a and $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Subtraction</entry>
        <entry>Remainder of $b subtracted from $a.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplication</entry>
        <entry>Product of $a and $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Division</entry>
        <entry>Dividend of $a and $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Modulus</entry>
        <entry>Remainder of $a divided by $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- This appears to be inaccurate. Division always returns a float.
    <simpara>
     The division operator ("/") returns an integer value (the result
     of an integer division) if the two operands are integers (or
     strings that get converted to integers). If either operand is a
     floating-point value, floating-point division is performed.
    </simpara>
-->

   <sect2 id="string-operators">
    <title>String Operators</title>
    <simpara>
     There is only really one string operator -- the concatenation
     operator (".").
    </simpara>
    <para>
     <informalexample><programlisting>
$a = "Hello ";
$b = $a . "World!"; // now $b = "Hello World!"
     </programlisting></informalexample>
    </para>

   <sect2 id="assignment-operators">
    <title>Assignment Operators</title>
    <simpara>
     The basic assignment operator is "=". Your first inclination might
     be to think of this as "equal to". Don't. It really means that
     the the left operand gets set to the value of the expression on the
     rights (that is, "gets set to").
    </simpara>
    <para>
     The value of an assignment expression is the value assigned. That
     is, the value of "$a = 3" is 3. This allows you to do some tricky
     things: <informalexample><programlisting>
$a = ($b = 4) + 5; // $a is equal to 9 now, and $b has been set to 4.
</programlisting></informalexample>
    </para>
    <para>
     In addition to the basic assignment operator, there are "combined
     operators" for all of the binary arithmetic and string operators
     that allow you to use a value in an expression and then set its
     value to the result of that expression. For example: <informalexample><programlisting>
$a = 3;
$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";
</programlisting></informalexample>
    </para>

   <sect2 id="bitwise-operators">
    <title>Bitwise Operators</title>
    <simpara>
     Bitwise operators allow you to turn specific bits within an integer
     on or off.
    </simpara>

    <table>
     <title>Bitwise Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>example</entry>
        <entry>name</entry>
        <entry>result</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a & $b</entry>
        <entry>And</entry>
        <entry>Bits that are set in both $a and $b are set.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>Or</entry>
        <entry>Bits that are set in either $a or $b are set.</entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>Not</entry>
        <entry>Bits that are set in $a are not set, and vice versa.</entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>Shift left</entry>
        <entry>Shift the bits of $a $b steps to the left (each step means "multiply by two")</entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>Shift right</entry>
        <entry>Shift the bits of $a $b steps to the right (each step means "divide by two")</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <sect2 id="logical-operators">
    <title>Logical Operators</title>

    <table>
     <title>Logical Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>example</entry>
        <entry>name</entry>
        <entry>result</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>And</entry>
        <entry>True of both $a and $b are true.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>Or</entry>
        <entry>True if either $a or $b is true.</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>Or</entry>
        <entry>True if either $a or $b is true, but not both.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>Not</entry>
        <entry>True if $a is not true.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>And</entry>
        <entry>True of both $a and $b are true.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>Or</entry>
        <entry>True if either $a or $b is true.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <simpara>
     The reason for the two different variations of "and" and "or"
     operators is that they operate at different precedences. (See below.)
    </simpara>

   <sect2 id="comparison-operators">
    <title>Comparison Operators</title>
    <simpara>
     Comparison operators, as their name imply, allow you to compare two
     values.
    </simpara>

    <table>
     <title>Comparson Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>example</entry>
        <entry>name</entry>
        <entry>result</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Equal</entry>
        <entry>True if $a is equal to $b.</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Not equal</entry>
        <entry>True if $a is not equal to $b.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Less than</entry>
        <entry>True if $a is strictly less than $b.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Greater than</entry>
        <entry>True if $a is strictly greater than $b.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Less than or equal to </entry>
        <entry>True if $a is less than or equal to $b.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Greater than or equal to </entry>
        <entry>True if $a is greater than or equal to $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     Another conditional operator is the "?:" (or trinary) operator, which
     operates as in C and many other languages. 
    <informalexample><programlisting>(expr1) ? (expr2) : (expr3);</programlisting></informalexample>
     This expression returns to <replaceable>expr2</replaceable> if
     <replaceable>expr1</replaceable> evalutes to true, and expr3 if
     <replaceable>expr1</replaceable> evaluates to false.

   <sect2 id="precedence">
    <title>Operator Precedence</title>
    <para>
     The precedence of an operator specifies how "tightly" it binds
     two expressions together. For example, in the expression
     <literal>1 + 5 * 3</literal>, the answer is 16 and not
     18 because the multiplication ("*") operator has a higher precedence
     than the addition ("+") operator.
    <para>
     The following table lists the precedence of operators with the
     lowest-precedence operators listed first.

    <table>
     <title>Operator Precedence</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativity</entry>
        <entry>Operators</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>left</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>= += -= *= /= .= %= &= != ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>== !=</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <sect1 id="control-structures">
   <title>Control Structures</title>
   <simpara>
    Any PHP script is built out of a series of statements. A statement can
    be an assignment, a function call, a loop, a conditional statement of
    even a statement that does nothing (an empty statement). Statements
    usually end with a semicolon. In addition, statements can be grouped
    into a statement-group by encapsulating a group of statements with
    curly braces. A statement-group is a statement by itself as well. The
    various statement types are described in this chapter.

   <sect2 id="construct.if">
    <title><literal>if</literal></title>
 
    <para>
     The <literal>if</literal> construct is one of the most important
     features of many languages, PHP included.  It allows for conditional
     execution of code fragments.  PHP features an <literal>if</literal>
     structure that is similar to that of C:

     <informalexample><programlisting>
 if (expr)
     statement
 </programlisting></informalexample>
 
    <simpara>
     As described in the section about expressions, expr is evaluated
     to its truth value.  If <replaceable>expr</replaceable> evaluates
     to <literal>TRUE</literal>, PHP will execute statement, and if it
     evaluates to <literal>FALSE</literal> - it'll ignore it.
 
    <para>
     The following example would display <computeroutput>a is bigger
     than b</computeroutput> if <replaceable>$a</replaceable> is bigger
     than <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b)
     print "a is bigger than b";
 </programlisting></informalexample>

    <para>
     Often you'd want to have more than one statement to be executed
     conditionally.  Of course, there's no need to wrap each statement
     with an <literal>if</literal> clause.  Instead, you can group
     several statements into a statement group.
     For example, this code would display <computeroutput>a is bigger than
     b</computeroutput> if <replaceable>$a</replaceable> is bigger than
     <replaceable>$b</replaceable>, and would then assign the value of
     <replaceable>$a</replaceable> into <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b) {
     print "a is bigger than b";
     $b = $a;
 }
 </programlisting></informalexample>
 
    <simpara>
     If statements can be nested indefinitely within other
     <literal>if</literal> statements, which provides you with complete
     flexibility for conditional execution of the various parts of
     your program.
 
   </sect2>
  
  <sect2 id="construct.else">
    <title><literal>else</literal></title>

    <para>
     Often you'd want to execute a statement if a certain condition
     is met, and a different statement if the condition is not met.
     This is what <literal>else</literal> is for.  <literal>else</literal>
     extends an <literal>if</literal> statement to execute a statement
     in case the expression in the <literal>if</literal> statement
     evaluates to <literal>FALSE</literal>.  For example, the following
     code would display <computeroutput>a is bigger than b</computeroutput>
     if <replaceable>$a</replaceable> is bigger than <replaceable>$b</replaceable>,
     and <computeroutput>a is NOT bigger than b</computeroutput> otherwise:

     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a is bigger than b";
 } else {
     print "a is NOT bigger than b";
 }
      </programlisting>
     </informalexample>
 
     The <literal>else</literal> statement is only executed
     if the <literal>if</literal> expression evaluated to
     <literal>FALSE</literal>, and if there were any <literal>elseif</literal>
     expressions - only if they evaluated to <literal>FALSE</literal>
     as well (see below).
 
   <sect2 id="construct.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal>, as its name suggests, is a combination
     of <literal>if</literal> and <literal>else</literal>.  Like
     <literal>else</literal>, it extends an <literal>if</literal>
     statement to execute a different statement in case the
     original <literal>if</literal> expression evaluates to
     <literal>FALSE</literal>.  However, unlike <literal>else</literal>,
     it will execute that alternative expression only if the
     <literal>elseif</literal> conditional expression evaluates to
     <literal>TRUE</literal>.  For example, the following code would
     display <computeroutput>a is bigger than b</computeroutput>,
     <computeroutput>a equal to b</computeroutput> or <computeroutput>a
     is smaller than b</computeroutput>:
 
     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a is bigger than b";
 } elseif ($a == $b) {
     print "a is equal to b";
 } else {
     print "a is smaller than b";
 }
      </programlisting>
     </informalexample>
 
    <simpara>
     There may be several <literal>elseif</literal>s within the same
     <literal>if</literal> statement.  The first <literal>elseif</literal>
     expression (if any) that evaluates to <literal>true</literal>
     would be executed.  In PHP, you can also write 'else if' (in two
     words) and the behavior would be identical to the one of 'elseif'
     (in a single word).  The syntactic meaning is slightly different
     (if you're familiar with C, this is the same behavior) but the
     bottom line is that both would result in exactly the same behavior.
     
    <simpara>
     The <literal>elseif</literal> statement is only executed if the preceding
     <literal>if</literal> expression and any
     preceding <literal>elseif</literal> expressions evaluated to <literal>FALSE</literal>, and the current
     <literal>elseif</literal> expression evaluated to <literal>TRUE</literal>.
 
    <sect2>
     <title>Alternative syntax for <literal>if</literal> structures: <literal>if(): ... endif;</literal></title>
 
     <para>
      PHP offers a different way to group statements within an
      <literal>if</literal> statement.  This is most commonly used when
      you nest HTML blocks inside <literal>if</literal> statements, but
      can be used anywhere.  Instead of using curly braces, <literal>if
      (<replaceable>expr</replaceable>)</literal> should be followed
      by a colon, the list of one or more statements, and end with
      <literal>endif;</literal>.  Consider the following example:
 
      <informalexample>
       <programlisting>
 &lt;?php if ($a==5): ?&gt;
 A = 5
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
 
     <simpara>
      In the above example, the HTML block "A = 5" is nested within an
      <literal>if</literal> statement written in the alternative syntax.
      The HTML block would be displayed only if $a is equal to 5.
 
     <para>
      The alternative syntax applies to <literal>else</literal>
      and <literal>elseif</literal> as well.  The following is an
      <literal>if</literal> structure with <literal>elseif</literal>
      and <literal>else</literal> in the alternative format:
      
      <informalexample>
       <programlisting>
 if ($a == 5):
     print "a equals 5";
     print "...";
 elseif ($a == 6):
     print "a equals 6";
     print "!!!";
 else:
     print "a is neither 5 nor 6";
 endif;
       </programlisting>
      </informalexample>
 
   <sect2 id="construct.while">
    <title><literal>while</literal></title>
 
    <para>
     <literal>while</literal> loops are the simplest type of loop in PHP.
     They behave just like their C counterparts.  The basic form of a
     <literal>while</literal> statement is:
 
     <informalexample>
      <programlisting>
 while (expr) statement
      </programlisting>
     </informalexample>
 
    <simpara>
     The meaning of a <literal>while</literal> statement is simple.
     It tells PHP to execute the nested statement(s) repeatedly,
     as long as the <literal>while</literal> expression evaluates
     to <literal>TRUE</literal>.  The value of the expression is
     checked each time at the beginning of the loop, so even if this
     value changes during the execution of the nested statement(s),
     execution will not stop until the end of the iteration (each
     time PHP runs the statements in the loop is one iteration).
     Sometimes, if the <literal>while</literal> expression evaluates
     to <literal>FALSE</literal> from the very beginning, the nested
     statement(s) won't even be run once.
 
    <para>
     Like with the <literal>if</literal> statement, you can group
     multiple statements within the same <literal>while</literal> loop
     by surrounding a group of statements with curly braces, or by using
     the alternate syntax:
 
     <informalexample>
      <programlisting>
     while (expr): statement ... endwhile;
 </programlisting></informalexample>
 
     <para>
      The following examples are identical, and both print numbers from
      1 to 10:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* the printed value would be
                     $i before the increment
                     (post-increment) */
 }
 
 /* example 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample>
 
 
   <sect2 id="construct.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
     <literal>do..while</literal> loops are very similar to
     <literal>while</literal> loops, except the truth expression is
     checked at the end of each iteration instead of in the beginning.
     The main difference from regular <literal>while</literal> loops
     is that the first iteration of a <literal>do..while</literal>
     loop is guarenteed to run (the truth expression is only checked
     at the end of the iteration), whereas it's may not necessarily run
     with a regular <literal>while</literal> loop (the truth expression
     is checked at the beginning of each iteration, if it evaluates
     to <literal>FALSE</literal> right from the beginning, the loop
     execution would end immediately).

    <para>
     There is just one syntax for <literal>do..while</literal> loops:
 
     <informalexample>
      <programlisting>
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample>
 
    <simpara>
     The above loop would run one time exactly, since after the first
     iteration, when truth expression is checked, it evaluates to
     <literal>FALSE</literal> ($i is not bigger than 0) and the loop
     execution ends.
 
    <para>
     Advanced C users may be familiar with a different usage of
     the <literal>do..while</literal> loop, to allow stopping
     execution in the middle of code blocks, by encapsulating
     them with <literal>do..while</literal>(0), and using the <link
     linkend="construct.break"><literal>break</literal></link> statement.
     The following code fragment demonstrates this:
 
     <informalexample>
      <programlisting>
 do {
     if ($i < 5) {
         print "i is not big enough";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i is ok";
     ...process i...
 } while(0);
      </programlisting>
     </informalexample>
 
    <simpara>
     Don't worry if you don't understand this right away or at all.
     You can code scripts and even powerful scripts without using this
     `feature'.
 
   <sect2 id="construct.for">
    <title><literal>for</literal></title>
 
    <para>
     <literal>for</literal> loops are the most complex loops in
     PHP.  They behave like their C counterparts.  The syntax of a
     <literal>for</literal> loop is:
 
     <informalexample>
      <programlisting>
for (expr1; expr2; expr3) statement
      </programlisting>
     </informalexample>
 
    <simpara>
     The first expression (<replaceable>expr1</replaceable>) is evaluated
     (executed) once unconditionally at the beginning of the loop.
 
    <simpara>
     In the beginning of each iteration, <replaceable>expr2</replaceable>
     is evaluated.  If it evaluates to <literal>TRUE</literal>, the
     loop continues and the nested statement(s) are executed.  If it
     evaluates to <literal>FALSE</literal>, the execution of the loop ends.
 
    <simpara>
     At the end of each iteration, <replaceable>expr3</replaceable>
     is evaluated (executed).

    <simpara>
     Each of the expressions can be empty.
     <replaceable>expr2</replaceable> being empty means
     the loop should be run indefinitely (PHP implicitly
     considers it as <literal>TRUE</literal>, like C).
     This may not be as useless as you might think, since
     often you'd want to end the loop using a conditional <link
     linkend="construct.break"><literal>break</literal></link> statement
     instead of using the <literal>for</literal> truth expression.
 
    <para>
     Consider the following examples.  All of them display numbers from
     1 to 10:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* example 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* example 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* example 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample>
 
    <simpara>
     Of course, the first example appears to be the nicest one (or
     perhaps the fourth), but you may find that being able to use empty
     expressions in <literal>for</literal> loops comes in handy in
     many occasions.
 
    <para>
     PHP also supports the alternate "colon syntax" for
     <literal>for</literal> loops.
 
     <informalexample>
      <programlisting>
 for (expr1; expr2; expr3): statement; ...; endfor;
      </programlisting>
     </informalexample>
 
    <para>
     Other languages have a foreach statement to traverse an array or
     hash. PHP uses the while statement and the <function>list</function>
     and <function>each</function> functions for this. See the
     documentation for these functions for an example.
 
 
   <sect2 id="construct.break">
    <title><literal>break</literal></title>
 
    <para>
     <literal>break</literal> breaks out of the current looping construct.
 
     <informalexample>
      <programlisting>
 $i = 0;
 while ($i < 10) {
     if ($arr[$i] == "stop") {
         break;
     }
     $i++;
 }
      </programlisting>
     </informalexample>
 
   <sect2 id="construct.continue">
    <title><literal>continue</literal></title>
 
    <para>
     <literal>continue</literal> jumps to the beginning of enclosing the looping
     construct.
 
     <informalexample>
      <programlisting>
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // skip even members
         continue;
     }
     do_something_odd ($value);
 }
      </programlisting>
     </informalexample>
 
   <sect2 id="construct.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     The <literal>switch</literal> statement is similar to a series
     of IF statements on the same expression.  In many occasions,
     you may want to compare the same variable (or expression) with
     many different values, and execute a different piece of code
     depending on which value it equals to.  This is exactly what the
     <literal>switch</literal> statement is for.
 
    <para>
     The following two examples are two different ways to write the
     same thing, one using a series of <literal>if</literal> statements,
     and the other using the <literal>switch</literal> statement:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 if ($i == 0) {
     print "i equals 0";
 }
 if ($i == 1) {
     print "i equals 1";
 }
 if ($i == 2) {
     print "i equals 2";
 }
 
 /* example 2 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
 }
      </programlisting>
     </informalexample>
 
    <para>
     It is important to understand how the <literal>switch</literal>
     statement is executed in order to avoid messups.  The
     <literal>switch</literal> statement executes line by line (actually,
     statement by statement).  In the beginning, no code is executed.
     Only when a <literal>case</literal> statement is found with a value that matches the
     value of the <literal>switch</literal> expression, PHP begins to
     execute the statements.  PHP continues to execute the statements
     until the end of the <literal>switch</literal> block, or the first
     time it sees a <literal>break</literal> statement.  If you don't
     write a <literal>break</literal> statement at the end of a case's
     statement list, PHP will go on executing the statements of the
     following case.  For example:
 
     <informalexample>
      <programlisting>
 /* example 3 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
     case 1:
         print "i equals 1";
     case 2:
         print "i equals 2";
 }
      </programlisting>
     </informalexample>
 
    <simpara>
     Here, if $i equals to 0, PHP would execute all of the print
     statements!  If $i equals to 1, PHP would execute the last
     two print statements, and only if $i equals to 2, you'd get the
     'expected' behavior and only 'i equals 2' would be displayed.  So,
     it's important not to forget <literal>break</literal> statements
     (even though you may want to avoid supplying them on purpose under
     certain circumstances).
 
    <para>
     A special case is the default case.  This case matches anything
     that wasn't matched by the other cases.  For example:
 
     <informalexample>
      <programlisting>
 /* example 4 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
     default:
         print "i is not equal to 0, 1 or 2";
 }
      </programlisting>
     </informalexample>
 
    <para>
     Another fact worth mentioning is that the <literal>case</literal>
     expression may be any expression that evaluates to a scalar type,
     that is, integer or floating-point numbers and strings.  Arrays or
     objects are meaningless in that context.
 
   <sect2 id="function.require">
    <title><literal>require</literal></title>
 
    <simpara>
     The <literal>require</literal> statement replaces itself with the
     specified file, much like the C preprocessor's #include works.

    <para>
     This means that you can't put a <literal>require</literal>
     statement inside of a loop structure and expect it to include the
     contents of a different file on each iteration. To do that, use an
     <literal>include</literal> statement.
 
     <informalexample>
      <programlisting>
 require 'header.inc';
      </programlisting>
     </informalexample>
 
   <sect2 id="function.include">
    <title><literal>include</literal></title>
 
    <simpara>
     The <literal>include</literal> statement includes and evaluates
     the specified file.
 
    <para>
     This happens each time the <literal>include</literal> statement is
     encountered, so you can use an <literal>include</literal> statement
     within a looping structure to include a number of different file.
 
     <informalexample>
      <programlisting>
 $files = array ('first.inc', 'second.inc', 'third.inc');
 for ($i = 0; $i < count($files); $i++) {
     include $files[$i];
 }
      </programlisting>
     </informalexample>

    <para>
     <link linkend="function.include"><literal>include</literal></link>
     differs from <link
     linkend="function.require"><literal>require</literal></link>
     in that the include statement is re-evaluated each time it is
     encountered (and only when it is being executed), whereas the
     <link linkend="function.require"><literal>require</literal></link>
     statement is replaced by the required file when it is first
     encountered, whether the contents of the file will be evaluated or
     not (for example, if it is inside an if statement whose condition
     evaluated to false).
 
    <para>
     Because <link
     linkend="function.include"><literal>include</literal></link> is a
     special language construct, you must enclose it within a statement
     block if it is inside a conditional block.
 
     <informalexample>
      <programlisting>
 /* This is WRONG and will not work as desired. */
 
 if ($condition)
     include($file);
 else
     include($other);
 
 /* This is CORRECT. */
 
 if ($condition) {
     include($file);
 } else {
     include($other);
 }
      </programlisting>
     </informalexample>
 
    <para>
     When the file is evaluated, the parser begins in "HTML-mode" which
     will output the contents of the file until the first PHP start tag
     (&lt;?)  is encountered.

    <para>
     See also <function>readfile</function>, <function>require</function>,
     <function>virtual</function>.
 
   <sect2 id="keyword.function">
    <title><literal>function</literal></title>
 
    <para>
     A function may be defined using syntax such as the following:
 
     <informalexample>
      <programlisting>
 function foo ($arg_1, $arg_2, ..., $arg_n) {
     echo "Example function.\n";
     return $retval;
 }
      </programlisting>
     </informalexample>
     
    <simpara>
     Any valid PHP code may appear inside a function, even other
     functions and <link linkend="keyword.class">class</link>
     definitions.
     
    <simpara>
     Functions must be defined before they are referenced.
 
    <sect3 id="keyword.function.return">
     <title>Returning values</title>
 
     <para>
      Values are returned by using the optional return statement. Any
      type may be returned, including lists and objects.
 
      <informalexample>
       <programlisting>
 function my_sqrt ($num) {
     return $num * $num;
 }
 echo my_sqrt (4);   // outputs '16'.
       </programlisting>
      </informalexample>
      
     <para>
      Multiple values may not be returned, but the same effect can be
      achieved by returning a list:
 
      <informalexample>
       <programlisting>
 function foo() {
    return array (0, 1, 2);
 }
 list ($zero, $one, $two) = foo();
       </programlisting>
      </informalexample>
 
    </sect3>
 
    <sect3 id="keyword.function.arguments">
     <title>Arguments</title>
 
     <simpara>
      Information may be passed to functions via the argument list,
      which is a comma-delimited list of variables and/or constants.
 
     <para>
      PHP supports passing arguments by value (the default), <link
      linkend="keyword.function.arguments.reference">passing by
      reference</link>, and <link
      linkend="keyword.function.arguments.default">default argument
      values</link>. Variable-length argument lists are not supported,
      but a similar effect may be achieved by passing arrays.
 
      <informalexample>
       <programlisting>
 function takes_array($input) {
     echo "$input[0] + $input[1] = ", $input[0]+$input[1];
 }
       </programlisting>
      </informalexample>
 
     <sect4 id="keyword.function.arguments.reference">
      <title>Passing by reference</title>
 
      <simpara>
       By default, function arguments are passed by value. If you wish
       to allow a function to modify its arguments, you may pass them
       by reference.
       
      <para>
       If you wish a function's argument to always be passed by
       reference, you can prepend an ampersand (&amp;) to the argument
       name in the function definition:
 
       <informalexample>
        <programlisting>
 function foo( &amp;$bar ) {
     $bar .= 'and something extra.';
 }
 $str = 'This is a string, ';
 foo ($str);
 echo $str;    // outputs 'This is a string, and something extra.'
        </programlisting>
       </informalexample>
 
      <para>
       If you wish to pass a variable by reference to a function which
       does not do this by default, you may prepend an ampersand to the 
       argument name in the function call:
 
       <informalexample>
        <programlisting>
 function foo ($bar) {
     $bar .= ' and something extra.';
 }
 $str = 'This is a string, ';
 foo ($str);
 echo $str;    // outputs 'This is a string, '
 foo (&amp;$str);
 echo $str;    // outputs 'This is a string, and something extra.'
        </programlisting>
       </informalexample>
 
     </sect4>
 
     <sect4 id="keyword.function.arguments.default">
      <title>Default values</title>
 
      <para>
       A function may define C++-style default values for scalar
       arguments as follows:
 
       <informalexample>
        <programlisting>
 function makecoffee ($type = "cappucino") {
     echo "Making a cup of $type.\n";
 }
 echo makecoffee ();
 echo makecoffee ("espresso");
        </programlisting>
       </informalexample>
 
      <para>
       The output from the above snippet is:
 
       <screen>
 Making a cup of cappucino.
 Making a cup of espresso.
       </screen>
 
      <simpara>
       The default value must be a constant expression, not (for
       example) a variable or class member.
 
      <para>
       Note that when using default arguments, any defaults should be
       on the right side of any non-default arguments; otherwise,
       things will not work as expected. Consider the following code
       snippet:
 
       <informalexample>
        <programlisting>
 function makeyogurt ($type = "acidophilus", $flavour) {
     return "Making a bowl of $type $flavour.\n";
 }
 
 echo makeyogurt ("raspberry");   // won't work as expected
        </programlisting>
       </informalexample>
 
      <para>
       The output of the above example is:
 
       <screen>
 Warning: Missing argument 2 in call to makeyogurt() in 
 /usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
 Making a bowl of raspberry .
       </screen>
 
      <para>
       Now, compare the above with this:
 
       <informalexample>
        <programlisting>
 function makeyogurt ($flavour, $type = "acidophilus") {
     return "Making a bowl of $type $flavour.\n";
 }
 
 echo makeyogurt ("raspberry");   // works as expected
        </programlisting>
       </informalexample>
 
      <para>
       The output of this example is:
 
       <screen>
 Making a bowl of acidophilus raspberry.
      </screen>
 
     </sect4>
 
    </sect3>
 
   </sect2>
            
 
   <sect2 id="keyword.old-function">
    <title><literal>old_function</literal></title>
 
    <simpara>
     The <literal>old_function</literal> statement allows you to declare
     a function using a syntax identical to PHP/FI2 (except you must
     replace 'function' with 'old_function'.
    <simpara>
     This is a deprecated feature, and should only be used by the
     PHP/FI2->PHP3 convertor.
    <simpara>
     Functions declared as <literal>old_function</literal>
     cannot be called from PHP's internal code. Among other
     things, this means you can't use them in functions such as
     <function>usort</function>, <function>array_walk</function>, and
     <function>register_shutdown_function</function>. You can get around
     this limitation by writing a wrapper function (in normal PHP3 form)
     to call the <literal>old_function</literal>.
   </sect2>
 
   <sect2 id="keyword.class">
    <title><literal>class</literal></title>
    <para>
     A class is a collection of variables and functions working with
     these variables.  A class is defined using the following syntax:
 
     <informalexample>
      <programlisting role=php>
 &lt;?php
 class Cart {
     var $items;  // Items in our shopping cart
   
     // Add $num articles of $artnr to the cart
 
     function add_item ($artnr, $num) {
         $this->items[$artnr] += $num;
     }
   
     // Take $num articles of $artnr out of the cart
 
     function remove_item ($artnr, $num) {
         if ($this->items[$artnr] > $num) {
             $this->items[$artnr] -= $num;
             return true;
         } else {
             return false;
         }   
     }
 }
 ?>
      </programlisting>
     </informalexample>
 
    <para>
     This defines a class named Cart that consists of an associative
     array of articles in the cart and two functions to add and remove
     items from this cart.
 
    </para><para>
     Classes are types, that is, they are blueprints for actual
     variables. You have to create a variables of the desired type with
     the new operator.
    </para>
 
    <informalexample>
     <programlisting role=php>
 $cart = new Cart;
 $cart->add_item("10", 1);
     </programlisting>
    </informalexample>
 
    <para>
     This creates an object $cart of the class Cart. The function
     add_item() of that object is being called to add 1 item of article
     number 10 to the cart.
    </para><para>
     Classes can be extensions of other classes. The extended or
     derived class has all variables and functions of the base class
     and what you add in the extended definition.  This is done using
     the extends keyword.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Named_Cart extends Cart {
     var $owner;
  
     function set_owner ($name) {
         $this->owner = $name;
     }
 }
     </programlisting>
    </informalexample>
 
    <para>
     This defines a class Named_Cart that has all variables and
     functions of Cart plus an additional variable $owner and an
     additional function set_owner(). You create a named cart the usual
     way and can now set and get the carts owner. You can still use
     normal cart functions on named carts:
    </para>
 
    <informalexample>
     <programlisting role=php>
 $ncart = new Named_Cart;    // Create a named cart
 $ncart->set_owner ("kris"); // Name that cart
 print $ncart->owner;        // print the cart owners name
 $ncart->add_item ("10", 1); // (inherited functionality from cart)
     </programlisting>
    </informalexample>
  
    <para>
     Within functions of a class the variable $this means this
     object. You have to use $this->something to access any variable or
     function named something within your current object.
    </para>
 
    <para>
     Constructors are functions in a class that are automatically 
     called when you create a new instance of a class. A function 
     becomes a constructor when it has the same name as the class.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Auto_Cart extends Cart {
     function Auto_Cart () {
         $this->add_item ("10", 1);
     }
 }
     </programlisting>
    </informalexample>
 
    <para>
     This defines a class Auto_Cart that is a Cart plus a constructor
     which initializes the cart with one item of article number "10"
     each time a new Auto_Cart is being made with "new". Constructors
     can also take arguments and these arguments can be optional, which
     makes them much more useful.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Constructor_Cart {
     function Constructor_Cart ($item = "10", $num = 1) {
         $this->add_item ($item, $num);
     }
 }
 
 // Shop the same old boring stuff.
 
 $default_cart   = new Constructor_Cart;
 
 // Shop for real...
 
 $different_cart = new Constructor_Cart ("20", 17);
     </programlisting>
    </informalexample>
 
    <caution>
     <simpara>
      For derived classes, the constructor of the parent class is not
      automatically called when the derived class's constructor is called.
    </caution>
 
  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
